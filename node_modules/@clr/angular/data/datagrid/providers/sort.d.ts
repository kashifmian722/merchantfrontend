import { Observable } from 'rxjs';
import { ClrDatagridComparatorInterface } from '../interfaces/comparator.interface';
import { StateDebouncer } from './state-debouncer.provider';
import * as ɵngcc0 from '@angular/core';
export declare class Sort<T = any> {
    private stateDebouncer;
    constructor(stateDebouncer: StateDebouncer);
    /**
     * Currently active comparator
     */
    private _comparator;
    get comparator(): ClrDatagridComparatorInterface<T>;
    set comparator(value: ClrDatagridComparatorInterface<T>);
    /**
     * Ascending order if false, descending if true
     */
    private _reverse;
    get reverse(): boolean;
    set reverse(value: boolean);
    /**
     * The Observable that lets other classes subscribe to sort changes
     */
    private _change;
    private emitChange;
    get change(): Observable<Sort<T>>;
    /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
     * optional forceReverse input parameter allows to override that toggling behavior by sorting in
     * reverse order if `true`.
     *
     * @memberof Sort
     */
    toggle(sortBy: ClrDatagridComparatorInterface<T>, forceReverse?: boolean): void;
    /**
     * Clears the current sorting order
     */
    clear(): void;
    /**
     * Compares two objects according to the current comparator
     */
    compare(a: T, b: T): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Sort<any>>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Sort<any>>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5kLnRzIiwic291cmNlcyI6WyJzb3J0LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBTb3J0PFQgPSBhbnk+IHtcbiAgICBwcml2YXRlIHN0YXRlRGVib3VuY2VyO1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlRGVib3VuY2VyOiBTdGF0ZURlYm91bmNlcik7XG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IGFjdGl2ZSBjb21wYXJhdG9yXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY29tcGFyYXRvcjtcbiAgICBnZXQgY29tcGFyYXRvcigpOiBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2U8VD47XG4gICAgc2V0IGNvbXBhcmF0b3IodmFsdWU6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPik7XG4gICAgLyoqXG4gICAgICogQXNjZW5kaW5nIG9yZGVyIGlmIGZhbHNlLCBkZXNjZW5kaW5nIGlmIHRydWVcbiAgICAgKi9cbiAgICBwcml2YXRlIF9yZXZlcnNlO1xuICAgIGdldCByZXZlcnNlKCk6IGJvb2xlYW47XG4gICAgc2V0IHJldmVyc2UodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBzb3J0IGNoYW5nZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIF9jaGFuZ2U7XG4gICAgcHJpdmF0ZSBlbWl0Q2hhbmdlO1xuICAgIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxTb3J0PFQ+PjtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY29tcGFyYXRvciBhcyB0aGUgY3VycmVudCBvbmUsIG9yIHRvZ2dsZXMgcmV2ZXJzZSBpZiB0aGUgY29tcGFyYXRvciBpcyBhbHJlYWR5IHVzZWQuIFRoZVxuICAgICAqIG9wdGlvbmFsIGZvcmNlUmV2ZXJzZSBpbnB1dCBwYXJhbWV0ZXIgYWxsb3dzIHRvIG92ZXJyaWRlIHRoYXQgdG9nZ2xpbmcgYmVoYXZpb3IgYnkgc29ydGluZyBpblxuICAgICAqIHJldmVyc2Ugb3JkZXIgaWYgYHRydWVgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNvcnRcbiAgICAgKi9cbiAgICB0b2dnbGUoc29ydEJ5OiBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2U8VD4sIGZvcmNlUmV2ZXJzZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY3VycmVudCBzb3J0aW5nIG9yZGVyXG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gb2JqZWN0cyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29tcGFyYXRvclxuICAgICAqL1xuICAgIGNvbXBhcmUoYTogVCwgYjogVCk6IG51bWJlcjtcbn1cbiJdfQ==