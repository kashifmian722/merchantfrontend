/**
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __extends, __param } from "tslib";
import { Component, Input, Optional, Renderer2 } from '@angular/core';
import { IfErrorService } from '../common/if-error/if-error.service';
import { NgControlService } from '../common/providers/ng-control.service';
import { LayoutService } from '../common/providers/layout.service';
import { ControlIdService } from '../common/providers/control-id.service';
import { ControlClassService } from '../common/providers/control-class.service';
import { ClrAbstractContainer } from '../common/abstract-container';
var ClrRangeContainer = /** @class */ (function (_super) {
    __extends(ClrRangeContainer, _super);
    function ClrRangeContainer(ifErrorService, layoutService, controlClassService, ngControlService, renderer, idService) {
        var _this = _super.call(this, ifErrorService, layoutService, controlClassService, ngControlService) || this;
        _this.renderer = renderer;
        _this.idService = idService;
        _this._hasProgress = false;
        return _this;
    }
    Object.defineProperty(ClrRangeContainer.prototype, "hasProgress", {
        get: function () {
            return this._hasProgress;
        },
        set: function (val) {
            var valBool = !!val;
            if (valBool !== this._hasProgress) {
                this._hasProgress = valBool;
            }
        },
        enumerable: true,
        configurable: true
    });
    ClrRangeContainer.prototype.getRangeProgressFillWidth = function () {
        var input = this.renderer.selectRootElement('[clrRange]#' + this.idService.id);
        var inputWidth = input.offsetWidth;
        var inputMinValue = +input.min;
        var inputMaxValue = +input.max;
        if (inputMinValue === 0 && inputMaxValue === 0) {
            inputMaxValue = 100;
        }
        var inputMiddle = (inputMinValue + inputMaxValue) / 2;
        var inputValue = !!this.control && this.control.value !== undefined ? this.control.value : inputMiddle;
        var valueAsPercent = (inputValue - inputMinValue) * 100 / (inputMaxValue - inputMinValue);
        return valueAsPercent * inputWidth / 100 + 'px';
    };
    ClrRangeContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: NgControlService },
        { type: Renderer2 },
        { type: ControlIdService }
    ]; };
    __decorate([
        Input('clrRangeHasProgress')
    ], ClrRangeContainer.prototype, "hasProgress", null);
    ClrRangeContainer = __decorate([
        Component({
            selector: 'clr-range-container',
            template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-range-wrapper\" [class.progress-fill]=\"hasProgress\">\n                <ng-content select=\"[clrRange]\"></ng-content>\n                <span\n                  *ngIf=\"hasProgress\"\n                  class=\"fill-input\"\n                  [style.width]=\"getRangeProgressFillWidth()\"\n                ></span>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
            host: {
                '[class.clr-form-control]': 'true',
                '[class.clr-form-control-disabled]': 'control?.disabled',
                '[class.clr-row]': 'addGrid()',
            },
            providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
        }),
        __param(1, Optional())
    ], ClrRangeContainer);
    return ClrRangeContainer;
}(ClrAbstractContainer));
export { ClrRangeContainer };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UtY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNsci9hbmd1bGFyLyIsInNvdXJjZXMiOlsiZm9ybXMvcmFuZ2UvcmFuZ2UtY29udGFpbmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7O0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV0RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDckUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDMUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBNEJwRTtJQUF1QyxxQ0FBb0I7SUFlekQsMkJBQ0UsY0FBOEIsRUFDbEIsYUFBNEIsRUFDeEMsbUJBQXdDLEVBQ3hDLGdCQUFrQyxFQUMxQixRQUFtQixFQUNuQixTQUEyQjtRQU5yQyxZQVFFLGtCQUFNLGNBQWMsRUFBRSxhQUFhLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsU0FDNUU7UUFKUyxjQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLGVBQVMsR0FBVCxTQUFTLENBQWtCO1FBcEI3QixrQkFBWSxHQUFZLEtBQUssQ0FBQzs7SUF1QnRDLENBQUM7SUFwQkQsc0JBQUksMENBQVc7YUFPZjtZQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzQixDQUFDO2FBVEQsVUFBZ0IsR0FBWTtZQUMxQixJQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3RCLElBQUksT0FBTyxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDO2FBQzdCO1FBQ0gsQ0FBQzs7O09BQUE7SUFpQkQscURBQXlCLEdBQXpCO1FBQ0UsSUFBTSxLQUFLLEdBQXFCLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFbkcsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUNyQyxJQUFNLGFBQWEsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDakMsSUFBSSxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBRS9CLElBQUksYUFBYSxLQUFLLENBQUMsSUFBSSxhQUFhLEtBQUssQ0FBQyxFQUFFO1lBQzlDLGFBQWEsR0FBRyxHQUFHLENBQUM7U0FDckI7UUFFRCxJQUFNLFdBQVcsR0FBRyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEQsSUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1FBQ3pHLElBQU0sY0FBYyxHQUFHLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUMsQ0FBQztRQUU1RixPQUFPLGNBQWMsR0FBRyxVQUFVLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztJQUNsRCxDQUFDOztnQkExQmlCLGNBQWM7Z0JBQ0gsYUFBYSx1QkFBdkMsUUFBUTtnQkFDWSxtQkFBbUI7Z0JBQ3RCLGdCQUFnQjtnQkFDaEIsU0FBUztnQkFDUixnQkFBZ0I7O0lBakJyQztRQURDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQzt3REFNNUI7SUFUVSxpQkFBaUI7UUExQjdCLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxxQkFBcUI7WUFDL0IsUUFBUSxFQUFFLGkzQkFnQlA7WUFDSCxJQUFJLEVBQUU7Z0JBQ0osMEJBQTBCLEVBQUUsTUFBTTtnQkFDbEMsbUNBQW1DLEVBQUUsbUJBQW1CO2dCQUN4RCxpQkFBaUIsRUFBRSxXQUFXO2FBQy9CO1lBQ0QsU0FBUyxFQUFFLENBQUMsY0FBYyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDO1NBQ3JGLENBQUM7UUFrQkcsV0FBQSxRQUFRLEVBQUUsQ0FBQTtPQWpCRixpQkFBaUIsQ0EyQzdCO0lBQUQsd0JBQUM7Q0FBQSxBQTNDRCxDQUF1QyxvQkFBb0IsR0EyQzFEO1NBM0NZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjAgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9wdGlvbmFsLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBDbHJBYnN0cmFjdENvbnRhaW5lciB9IGZyb20gJy4uL2NvbW1vbi9hYnN0cmFjdC1jb250YWluZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFuZ2UtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItcmFuZ2Utd3JhcHBlclwiIFtjbGFzcy5wcm9ncmVzcy1maWxsXT1cImhhc1Byb2dyZXNzXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclJhbmdlXVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNQcm9ncmVzc1wiXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImZpbGwtaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoXT1cImdldFJhbmdlUHJvZ3Jlc3NGaWxsV2lkdGgoKVwiXG4gICAgICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmRXJyb3JTZXJ2aWNlLCBOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sSWRTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUmFuZ2VDb250YWluZXIgZXh0ZW5kcyBDbHJBYnN0cmFjdENvbnRhaW5lciB7XG4gIHByaXZhdGUgX2hhc1Byb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQElucHV0KCdjbHJSYW5nZUhhc1Byb2dyZXNzJylcbiAgc2V0IGhhc1Byb2dyZXNzKHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5faGFzUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuX2hhc1Byb2dyZXNzID0gdmFsQm9vbDtcbiAgICB9XG4gIH1cblxuICBnZXQgaGFzUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1Byb2dyZXNzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGlkU2VydmljZTogQ29udHJvbElkU2VydmljZVxuICApIHtcbiAgICBzdXBlcihpZkVycm9yU2VydmljZSwgbGF5b3V0U2VydmljZSwgY29udHJvbENsYXNzU2VydmljZSwgbmdDb250cm9sU2VydmljZSk7XG4gIH1cblxuICBnZXRSYW5nZVByb2dyZXNzRmlsbFdpZHRoKCk6IHN0cmluZyB7XG4gICAgY29uc3QgaW5wdXQgPSA8SFRNTElucHV0RWxlbWVudD50aGlzLnJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KCdbY2xyUmFuZ2VdIycgKyB0aGlzLmlkU2VydmljZS5pZCk7XG5cbiAgICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGg7XG4gICAgY29uc3QgaW5wdXRNaW5WYWx1ZSA9ICtpbnB1dC5taW47XG4gICAgbGV0IGlucHV0TWF4VmFsdWUgPSAraW5wdXQubWF4O1xuXG4gICAgaWYgKGlucHV0TWluVmFsdWUgPT09IDAgJiYgaW5wdXRNYXhWYWx1ZSA9PT0gMCkge1xuICAgICAgaW5wdXRNYXhWYWx1ZSA9IDEwMDtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dE1pZGRsZSA9IChpbnB1dE1pblZhbHVlICsgaW5wdXRNYXhWYWx1ZSkgLyAyO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSAhIXRoaXMuY29udHJvbCAmJiB0aGlzLmNvbnRyb2wudmFsdWUgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29udHJvbC52YWx1ZSA6IGlucHV0TWlkZGxlO1xuICAgIGNvbnN0IHZhbHVlQXNQZXJjZW50ID0gKGlucHV0VmFsdWUgLSBpbnB1dE1pblZhbHVlKSAqIDEwMCAvIChpbnB1dE1heFZhbHVlIC0gaW5wdXRNaW5WYWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWVBc1BlcmNlbnQgKiBpbnB1dFdpZHRoIC8gMTAwICsgJ3B4JztcbiAgfVxufVxuIl19