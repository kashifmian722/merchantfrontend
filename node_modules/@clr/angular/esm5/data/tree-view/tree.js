/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { AfterContentInit, Component, ContentChildren, ElementRef, HostListener, Input, OnDestroy, QueryList, } from '@angular/core';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNode } from './tree-node';
var ClrTree = /** @class */ (function () {
    function ClrTree(featuresService, focusManagerService, el) {
        this.featuresService = featuresService;
        this.focusManagerService = focusManagerService;
        this.el = el;
        this.subscriptions = [];
        this.tabindex = 0;
    }
    Object.defineProperty(ClrTree.prototype, "lazy", {
        set: function (value) {
            this.featuresService.eager = !value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTree.prototype, "isMultiSelectable", {
        get: function () {
            return this.featuresService.selectable && this.rootNodes.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    ClrTree.prototype.onFocusIn = function (event) {
        if (event.target === this.el.nativeElement) {
            // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
            // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
            this.focusManagerService.focusFirstVisibleNode();
            // when the first child gets focus,
            // tree should no longer have tabindex of 0;
            delete this.tabindex;
        }
    };
    ClrTree.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.setRootNodes();
        this.subscriptions.push(this.rootNodes.changes.subscribe(function () {
            _this.setRootNodes();
        }));
    };
    ClrTree.prototype.setRootNodes = function () {
        // if node has no parent, it's a root node
        // for recursive tree, this.rootNodes registers also nested children
        // so we have to use filter to extract the ones that are truly root nodes
        this.focusManagerService.rootNodeModels = this.rootNodes.map(function (node) { return node._model; }).filter(function (node) { return !node.parent; });
    };
    ClrTree.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrTree.ctorParameters = function () { return [
        { type: TreeFeaturesService },
        { type: TreeFocusManagerService },
        { type: ElementRef }
    ]; };
    __decorate([
        Input('clrLazy')
    ], ClrTree.prototype, "lazy", null);
    __decorate([
        HostListener('focusin', ['$event'])
    ], ClrTree.prototype, "onFocusIn", null);
    __decorate([
        ContentChildren(ClrTreeNode)
    ], ClrTree.prototype, "rootNodes", void 0);
    ClrTree = __decorate([
        Component({
            selector: 'clr-tree',
            template: "\n    <ng-content></ng-content>\n    <clr-recursive-children *ngIf=\"featuresService.recursion\"\n                            [children]=\"featuresService.recursion.root\"></clr-recursive-children>\n  ",
            providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
            host: {
                '[attr.tabindex]': 'tabindex',
                '[attr.role]': '"tree"',
                '[attr.aria-multiselectable]': 'isMultiSelectable',
            }
        })
    ], ClrTree);
    return ClrTree;
}());
export { ClrTree };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjbHIvYW5ndWxhci8iLCJzb3VyY2VzIjpbImRhdGEvdHJlZS12aWV3L3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRzs7QUFFSCxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN2RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN0RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBZ0IxQztJQUNFLGlCQUNTLGVBQXVDLEVBQ3RDLG1CQUErQyxFQUMvQyxFQUFjO1FBRmYsb0JBQWUsR0FBZixlQUFlLENBQXdCO1FBQ3RDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBNEI7UUFDL0MsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUdoQixrQkFBYSxHQUFtQixFQUFFLENBQUM7UUFPM0MsYUFBUSxHQUFHLENBQUMsQ0FBQztJQVRWLENBQUM7SUFLSixzQkFBSSx5QkFBSTthQUFSLFVBQVMsS0FBYztZQUNyQixJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssR0FBRyxDQUFDLEtBQUssQ0FBQztRQUN0QyxDQUFDOzs7T0FBQTtJQUlELHNCQUFJLHNDQUFpQjthQUFyQjtZQUNFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ3RFLENBQUM7OztPQUFBO0lBR0QsMkJBQVMsR0FBVCxVQUFVLEtBQWlCO1FBQ3pCLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRTtZQUMxQyw2SEFBNkg7WUFDN0gscUhBQXFIO1lBQ3JILElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBRWpELG1DQUFtQztZQUNuQyw0Q0FBNEM7WUFDNUMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQ3RCO0lBQ0gsQ0FBQztJQUlELG9DQUFrQixHQUFsQjtRQUFBLGlCQU9DO1FBTkMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7WUFDL0IsS0FBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRU8sOEJBQVksR0FBcEI7UUFDRSwwQ0FBMEM7UUFDMUMsb0VBQW9FO1FBQ3BFLHlFQUF5RTtRQUN6RSxJQUFJLENBQUMsbUJBQW1CLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sRUFBWCxDQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQVosQ0FBWSxDQUFDLENBQUM7SUFDakgsQ0FBQztJQUVELDZCQUFXLEdBQVg7UUFDRSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsQ0FBQyxXQUFXLEVBQUUsRUFBakIsQ0FBaUIsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7O2dCQW5EeUIsbUJBQW1CO2dCQUNkLHVCQUF1QjtnQkFDeEMsVUFBVTs7SUFNeEI7UUFEQyxLQUFLLENBQUMsU0FBUyxDQUFDO3VDQUdoQjtJQVNEO1FBREMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzRDQVduQztJQUU2QjtRQUE3QixlQUFlLENBQUMsV0FBVyxDQUFDOzhDQUE4QztJQWpDaEUsT0FBTztRQWRuQixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsVUFBVTtZQUNwQixRQUFRLEVBQUUsMk1BSVQ7WUFDRCxTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSx1QkFBdUIsQ0FBQztZQUM1RCxJQUFJLEVBQUU7Z0JBQ0osaUJBQWlCLEVBQUUsVUFBVTtnQkFDN0IsYUFBYSxFQUFFLFFBQVE7Z0JBQ3ZCLDZCQUE2QixFQUFFLG1CQUFtQjthQUNuRDtTQUNGLENBQUM7T0FDVyxPQUFPLENBc0RuQjtJQUFELGNBQUM7Q0FBQSxBQXRERCxJQXNEQztTQXREWSxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vdHJlZS1mb2N1cy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSwgVFJFRV9GRUFUVVJFU19QUk9WSURFUiB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRyZWVOb2RlIH0gZnJvbSAnLi90cmVlLW5vZGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdHJlZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxjbHItcmVjdXJzaXZlLWNoaWxkcmVuICpuZ0lmPVwiZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NoaWxkcmVuXT1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24ucm9vdFwiPjwvY2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbj5cbiAgYCxcbiAgcHJvdmlkZXJzOiBbVFJFRV9GRUFUVVJFU19QUk9WSURFUiwgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJpbmRleCcsXG4gICAgJ1thdHRyLnJvbGVdJzogJ1widHJlZVwiJyxcbiAgICAnW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdJzogJ2lzTXVsdGlTZWxlY3RhYmxlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBmb2N1c01hbmFnZXJTZXJ2aWNlOiBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmXG4gICkge31cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJMYXp5JylcbiAgc2V0IGxhenkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciA9ICF2YWx1ZTtcbiAgfVxuXG4gIHRhYmluZGV4ID0gMDtcblxuICBnZXQgaXNNdWx0aVNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgJiYgdGhpcy5yb290Tm9kZXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IEZvY3VzRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgIC8vIEFmdGVyIGRpc2N1c3Npbmcgd2l0aCB0aGUgdGVhbSwgSSd2ZSBtYWRlIGl0IHNvIHRoYXQgd2hlbiB0aGUgdHJlZSByZWNlaXZlcyBmb2N1cywgdGhlIGZpcnN0IHZpc2libGUgbm9kZSB3aWxsIGJlIGZvY3VzZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmcm9tIHRoZSBwYWdlIHNjcm9sbGluZyBhYnJ1cHRseSB0byB0aGUgZmlyc3Qgc2VsZWN0ZWQgbm9kZSBpZiBpdCBleGlzdCBpbiBhIGRlZXBseSBuZXN0ZWQgdHJlZS5cbiAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcblxuICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgY2hpbGQgZ2V0cyBmb2N1cyxcbiAgICAgIC8vIHRyZWUgc2hvdWxkIG5vIGxvbmdlciBoYXZlIHRhYmluZGV4IG9mIDA7XG4gICAgICBkZWxldGUgdGhpcy50YWJpbmRleDtcbiAgICB9XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKENsclRyZWVOb2RlKSBwcml2YXRlIHJvb3ROb2RlczogUXVlcnlMaXN0PENsclRyZWVOb2RlPFQ+PjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucm9vdE5vZGVzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Um9vdE5vZGVzKCk6IHZvaWQge1xuICAgIC8vIGlmIG5vZGUgaGFzIG5vIHBhcmVudCwgaXQncyBhIHJvb3Qgbm9kZVxuICAgIC8vIGZvciByZWN1cnNpdmUgdHJlZSwgdGhpcy5yb290Tm9kZXMgcmVnaXN0ZXJzIGFsc28gbmVzdGVkIGNoaWxkcmVuXG4gICAgLy8gc28gd2UgaGF2ZSB0byB1c2UgZmlsdGVyIHRvIGV4dHJhY3QgdGhlIG9uZXMgdGhhdCBhcmUgdHJ1bHkgcm9vdCBub2Rlc1xuICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5yb290Tm9kZU1vZGVscyA9IHRoaXMucm9vdE5vZGVzLm1hcChub2RlID0+IG5vZGUuX21vZGVsKS5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIl19