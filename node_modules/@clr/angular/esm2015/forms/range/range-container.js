/**
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { Component, Input, Optional, Renderer2 } from '@angular/core';
import { IfErrorService } from '../common/if-error/if-error.service';
import { NgControlService } from '../common/providers/ng-control.service';
import { LayoutService } from '../common/providers/layout.service';
import { ControlIdService } from '../common/providers/control-id.service';
import { ControlClassService } from '../common/providers/control-class.service';
import { ClrAbstractContainer } from '../common/abstract-container';
let ClrRangeContainer = class ClrRangeContainer extends ClrAbstractContainer {
    constructor(ifErrorService, layoutService, controlClassService, ngControlService, renderer, idService) {
        super(ifErrorService, layoutService, controlClassService, ngControlService);
        this.renderer = renderer;
        this.idService = idService;
        this._hasProgress = false;
    }
    set hasProgress(val) {
        const valBool = !!val;
        if (valBool !== this._hasProgress) {
            this._hasProgress = valBool;
        }
    }
    get hasProgress() {
        return this._hasProgress;
    }
    getRangeProgressFillWidth() {
        const input = this.renderer.selectRootElement('[clrRange]#' + this.idService.id);
        const inputWidth = input.offsetWidth;
        const inputMinValue = +input.min;
        let inputMaxValue = +input.max;
        if (inputMinValue === 0 && inputMaxValue === 0) {
            inputMaxValue = 100;
        }
        const inputMiddle = (inputMinValue + inputMaxValue) / 2;
        const inputValue = !!this.control && this.control.value !== undefined ? this.control.value : inputMiddle;
        const valueAsPercent = (inputValue - inputMinValue) * 100 / (inputMaxValue - inputMinValue);
        return valueAsPercent * inputWidth / 100 + 'px';
    }
};
ClrRangeContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService },
    { type: Renderer2 },
    { type: ControlIdService }
];
__decorate([
    Input('clrRangeHasProgress')
], ClrRangeContainer.prototype, "hasProgress", null);
ClrRangeContainer = __decorate([
    Component({
        selector: 'clr-range-container',
        template: `
        <ng-content select="label"></ng-content>
        <label *ngIf="!label && addGrid()"></label>
        <div class="clr-control-container" [ngClass]="controlClass()">
            <div class="clr-range-wrapper" [class.progress-fill]="hasProgress">
                <ng-content select="[clrRange]"></ng-content>
                <span
                  *ngIf="hasProgress"
                  class="fill-input"
                  [style.width]="getRangeProgressFillWidth()"
                ></span>
                <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
            </div>
            <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
            <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
        </div>
    `,
        host: {
            '[class.clr-form-control]': 'true',
            '[class.clr-form-control-disabled]': 'control?.disabled',
            '[class.clr-row]': 'addGrid()',
        },
        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
    }),
    __param(1, Optional())
], ClrRangeContainer);
export { ClrRangeContainer };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UtY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNsci9hbmd1bGFyLyIsInNvdXJjZXMiOlsiZm9ybXMvcmFuZ2UvcmFuZ2UtY29udGFpbmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7O0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV0RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDckUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDMUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBNEJwRSxJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFrQixTQUFRLG9CQUFvQjtJQWV6RCxZQUNFLGNBQThCLEVBQ2xCLGFBQTRCLEVBQ3hDLG1CQUF3QyxFQUN4QyxnQkFBa0MsRUFDMUIsUUFBbUIsRUFDbkIsU0FBMkI7UUFFbkMsS0FBSyxDQUFDLGNBQWMsRUFBRSxhQUFhLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUhwRSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBcEI3QixpQkFBWSxHQUFZLEtBQUssQ0FBQztJQXVCdEMsQ0FBQztJQXBCRCxJQUFJLFdBQVcsQ0FBQyxHQUFZO1FBQzFCLE1BQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDdEIsSUFBSSxPQUFPLEtBQUssSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQyxJQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQztTQUM3QjtJQUNILENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQWFELHlCQUF5QjtRQUN2QixNQUFNLEtBQUssR0FBcUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVuRyxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ3JDLE1BQU0sYUFBYSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNqQyxJQUFJLGFBQWEsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFFL0IsSUFBSSxhQUFhLEtBQUssQ0FBQyxJQUFJLGFBQWEsS0FBSyxDQUFDLEVBQUU7WUFDOUMsYUFBYSxHQUFHLEdBQUcsQ0FBQztTQUNyQjtRQUVELE1BQU0sV0FBVyxHQUFHLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4RCxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7UUFDekcsTUFBTSxjQUFjLEdBQUcsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxDQUFDO1FBRTVGLE9BQU8sY0FBYyxHQUFHLFVBQVUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO0lBQ2xELENBQUM7Q0FDRixDQUFBOztZQTNCbUIsY0FBYztZQUNILGFBQWEsdUJBQXZDLFFBQVE7WUFDWSxtQkFBbUI7WUFDdEIsZ0JBQWdCO1lBQ2hCLFNBQVM7WUFDUixnQkFBZ0I7O0FBakJyQztJQURDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQztvREFNNUI7QUFUVSxpQkFBaUI7SUExQjdCLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxxQkFBcUI7UUFDL0IsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JQO1FBQ0gsSUFBSSxFQUFFO1lBQ0osMEJBQTBCLEVBQUUsTUFBTTtZQUNsQyxtQ0FBbUMsRUFBRSxtQkFBbUI7WUFDeEQsaUJBQWlCLEVBQUUsV0FBVztTQUMvQjtRQUNELFNBQVMsRUFBRSxDQUFDLGNBQWMsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsQ0FBQztLQUNyRixDQUFDO0lBa0JHLFdBQUEsUUFBUSxFQUFFLENBQUE7R0FqQkYsaUJBQWlCLENBMkM3QjtTQTNDWSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIwIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPcHRpb25hbCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQWJzdHJhY3RDb250YWluZXIgfSBmcm9tICcuLi9jb21tb24vYWJzdHJhY3QtY29udGFpbmVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXJhbmdlLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLXJhbmdlLXdyYXBwZXJcIiBbY2xhc3MucHJvZ3Jlc3MtZmlsbF09XCJoYXNQcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJSYW5nZV1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzUHJvZ3Jlc3NcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmaWxsLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aF09XCJnZXRSYW5nZVByb2dyZXNzRmlsbFdpZHRoKClcIlxuICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZkVycm9yU2VydmljZSwgTmdDb250cm9sU2VydmljZSwgQ29udHJvbElkU2VydmljZSwgQ29udHJvbENsYXNzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclJhbmdlQ29udGFpbmVyIGV4dGVuZHMgQ2xyQWJzdHJhY3RDb250YWluZXIge1xuICBwcml2YXRlIF9oYXNQcm9ncmVzczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgnY2xyUmFuZ2VIYXNQcm9ncmVzcycpXG4gIHNldCBoYXNQcm9ncmVzcyh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX2hhc1Byb2dyZXNzKSB7XG4gICAgICB0aGlzLl9oYXNQcm9ncmVzcyA9IHZhbEJvb2w7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGhhc1Byb2dyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNQcm9ncmVzcztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBpZFNlcnZpY2U6IENvbnRyb2xJZFNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoaWZFcnJvclNlcnZpY2UsIGxheW91dFNlcnZpY2UsIGNvbnRyb2xDbGFzc1NlcnZpY2UsIG5nQ29udHJvbFNlcnZpY2UpO1xuICB9XG5cbiAgZ2V0UmFuZ2VQcm9ncmVzc0ZpbGxXaWR0aCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGlucHV0ID0gPEhUTUxJbnB1dEVsZW1lbnQ+dGhpcy5yZW5kZXJlci5zZWxlY3RSb290RWxlbWVudCgnW2NsclJhbmdlXSMnICsgdGhpcy5pZFNlcnZpY2UuaWQpO1xuXG4gICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0Lm9mZnNldFdpZHRoO1xuICAgIGNvbnN0IGlucHV0TWluVmFsdWUgPSAraW5wdXQubWluO1xuICAgIGxldCBpbnB1dE1heFZhbHVlID0gK2lucHV0Lm1heDtcblxuICAgIGlmIChpbnB1dE1pblZhbHVlID09PSAwICYmIGlucHV0TWF4VmFsdWUgPT09IDApIHtcbiAgICAgIGlucHV0TWF4VmFsdWUgPSAxMDA7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRNaWRkbGUgPSAoaW5wdXRNaW5WYWx1ZSArIGlucHV0TWF4VmFsdWUpIC8gMjtcbiAgICBjb25zdCBpbnB1dFZhbHVlID0gISF0aGlzLmNvbnRyb2wgJiYgdGhpcy5jb250cm9sLnZhbHVlICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbnRyb2wudmFsdWUgOiBpbnB1dE1pZGRsZTtcbiAgICBjb25zdCB2YWx1ZUFzUGVyY2VudCA9IChpbnB1dFZhbHVlIC0gaW5wdXRNaW5WYWx1ZSkgKiAxMDAgLyAoaW5wdXRNYXhWYWx1ZSAtIGlucHV0TWluVmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlQXNQZXJjZW50ICogaW5wdXRXaWR0aCAvIDEwMCArICdweCc7XG4gIH1cbn1cbiJdfQ==