import { __decorate, __param } from "tslib";
/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { ComponentFactoryResolver, Directive, ElementRef, HostBinding, HostListener, Inject, Input, ViewContainerRef, } from '@angular/core';
import { IF_ACTIVE_ID, IfActiveService } from '../../utils/conditional/if-active.service';
import { TemplateRefContainer } from '../../utils/template-ref/template-ref-container';
import { TabsService } from './providers/tabs.service';
import { AriaService } from './providers/aria.service';
import { TABS_ID } from './tabs-id.provider';
import { TabsLayout } from './enums/tabs-layout.enum';
let nbTabLinkComponents = 0;
let ClrTabLink = class ClrTabLink {
    constructor(ifActiveService, id, ariaService, el, cfr, viewContainerRef, tabsService, tabsId) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.ariaService = ariaService;
        this.el = el;
        this.cfr = cfr;
        this.viewContainerRef = viewContainerRef;
        this.tabsService = tabsService;
        this.tabsId = tabsId;
        if (!this.tabLinkId) {
            this.tabLinkId = 'clr-tab-link-' + nbTabLinkComponents++;
        }
        // Tab links can be rendered in one of two places: in the main area or inside the overflow dropdown menu.
        // Here, we create a container so that its template can be used to create embeddedView on the fly.
        // See TabsService's renderView() method and how it's used in Tabs class for an example.
        const factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
        this.templateRefContainer = this.viewContainerRef.createComponent(factory, undefined, undefined, [
            [this.el.nativeElement],
        ]).instance;
    }
    set inOverflow(inOverflow) {
        this._inOverflow = inOverflow;
    }
    get inOverflow() {
        return this._inOverflow && this.tabsService.layout !== TabsLayout.VERTICAL;
    }
    get addLinkClasses() {
        return !this.inOverflow;
    }
    get ariaControls() {
        return this.ariaService.ariaControls;
    }
    get tabLinkId() {
        return this.ariaService.ariaLabelledBy;
    }
    set tabLinkId(id) {
        this.ariaService.ariaLabelledBy = id;
    }
    activate() {
        this.ifActiveService.current = this.id;
    }
    get active() {
        return this.ifActiveService.current === this.id;
    }
    get tabindex() {
        return this.active ? 0 : -1;
    }
};
ClrTabLink.ctorParameters = () => [
    { type: IfActiveService },
    { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
    { type: AriaService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: TabsService },
    { type: Number, decorators: [{ type: Inject, args: [TABS_ID,] }] }
];
__decorate([
    Input('clrTabLinkInOverflow')
], ClrTabLink.prototype, "inOverflow", null);
__decorate([
    HostBinding('class.btn-link'),
    HostBinding('class.nav-link')
], ClrTabLink.prototype, "addLinkClasses", null);
__decorate([
    HostBinding('attr.aria-controls')
], ClrTabLink.prototype, "ariaControls", null);
__decorate([
    HostBinding('id'),
    Input('id')
], ClrTabLink.prototype, "tabLinkId", null);
__decorate([
    HostListener('click')
], ClrTabLink.prototype, "activate", null);
__decorate([
    HostBinding('class.active'),
    HostBinding('attr.aria-selected')
], ClrTabLink.prototype, "active", null);
__decorate([
    HostBinding('attr.tabindex')
], ClrTabLink.prototype, "tabindex", null);
ClrTabLink = __decorate([
    Directive({
        selector: '[clrTabLink]',
        host: {
            '[attr.aria-hidden]': 'false',
            '[class.btn]': 'true',
            role: 'tab',
            type: 'button',
        },
    }),
    __param(1, Inject(IF_ACTIVE_ID)),
    __param(7, Inject(TABS_ID))
], ClrTabLink);
export { ClrTabLink };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWxpbmsuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNsci9hbmd1bGFyLyIsInNvdXJjZXMiOlsibGF5b3V0L3RhYnMvdGFiLWxpbmsuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHO0FBQ0gsT0FBTyxFQUNMLHdCQUF3QixFQUN4QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFdBQVcsRUFDWCxZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFDTCxnQkFBZ0IsR0FDakIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUMxRixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpREFBaUQsQ0FBQztBQUN2RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFdkQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFdEQsSUFBSSxtQkFBbUIsR0FBVyxDQUFDLENBQUM7QUFXcEMsSUFBYSxVQUFVLEdBQXZCLE1BQWEsVUFBVTtJQW9CckIsWUFDUyxlQUFnQyxFQUNULEVBQVUsRUFDaEMsV0FBd0IsRUFDekIsRUFBYyxFQUNiLEdBQTZCLEVBQzdCLGdCQUFrQyxFQUNsQyxXQUF3QixFQUNSLE1BQWM7UUFQL0Isb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ1QsT0FBRSxHQUFGLEVBQUUsQ0FBUTtRQUNoQyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN6QixPQUFFLEdBQUYsRUFBRSxDQUFZO1FBQ2IsUUFBRyxHQUFILEdBQUcsQ0FBMEI7UUFDN0IscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxnQkFBVyxHQUFYLFdBQVcsQ0FB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QU0sQ0FBQyxPQUFPLENBQUMsQ0FBQTtHQTVCUCxVQUFVLENBeUV0QjtTQXpFWSxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIwIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IFRlbXBsYXRlUmVmQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi1jb250YWluZXInO1xuaW1wb3J0IHsgVGFic1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJzLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBBcmlhU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2FyaWEuc2VydmljZSc7XG5pbXBvcnQgeyBUQUJTX0lEIH0gZnJvbSAnLi90YWJzLWlkLnByb3ZpZGVyJztcbmltcG9ydCB7IFRhYnNMYXlvdXQgfSBmcm9tICcuL2VudW1zL3RhYnMtbGF5b3V0LmVudW0nO1xuXG5sZXQgbmJUYWJMaW5rQ29tcG9uZW50czogbnVtYmVyID0gMDtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsclRhYkxpbmtdJyxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAnZmFsc2UnLFxuICAgICdbY2xhc3MuYnRuXSc6ICd0cnVlJyxcbiAgICByb2xlOiAndGFiJyxcbiAgICB0eXBlOiAnYnV0dG9uJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFiTGluayB7XG4gIHByaXZhdGUgX2luT3ZlcmZsb3c6IGJvb2xlYW47XG5cbiAgQElucHV0KCdjbHJUYWJMaW5rSW5PdmVyZmxvdycpXG4gIHNldCBpbk92ZXJmbG93KGluT3ZlcmZsb3cpIHtcbiAgICB0aGlzLl9pbk92ZXJmbG93ID0gaW5PdmVyZmxvdztcbiAgfVxuXG4gIGdldCBpbk92ZXJmbG93KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pbk92ZXJmbG93ICYmIHRoaXMudGFic1NlcnZpY2UubGF5b3V0ICE9PSBUYWJzTGF5b3V0LlZFUlRJQ0FMO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5idG4tbGluaycpXG4gIEBIb3N0QmluZGluZygnY2xhc3MubmF2LWxpbmsnKVxuICBnZXQgYWRkTGlua0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuICF0aGlzLmluT3ZlcmZsb3c7XG4gIH1cblxuICB0ZW1wbGF0ZVJlZkNvbnRhaW5lcjogVGVtcGxhdGVSZWZDb250YWluZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBwcml2YXRlIGlkOiBudW1iZXIsXG4gICAgcHJpdmF0ZSBhcmlhU2VydmljZTogQXJpYVNlcnZpY2UsXG4gICAgcHVibGljIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgY2ZyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgdGFic1NlcnZpY2U6IFRhYnNTZXJ2aWNlLFxuICAgIEBJbmplY3QoVEFCU19JRCkgcHVibGljIHRhYnNJZDogbnVtYmVyXG4gICkge1xuICAgIGlmICghdGhpcy50YWJMaW5rSWQpIHtcbiAgICAgIHRoaXMudGFiTGlua0lkID0gJ2Nsci10YWItbGluay0nICsgbmJUYWJMaW5rQ29tcG9uZW50cysrO1xuICAgIH1cblxuICAgIC8vIFRhYiBsaW5rcyBjYW4gYmUgcmVuZGVyZWQgaW4gb25lIG9mIHR3byBwbGFjZXM6IGluIHRoZSBtYWluIGFyZWEgb3IgaW5zaWRlIHRoZSBvdmVyZmxvdyBkcm9wZG93biBtZW51LlxuICAgIC8vIEhlcmUsIHdlIGNyZWF0ZSBhIGNvbnRhaW5lciBzbyB0aGF0IGl0cyB0ZW1wbGF0ZSBjYW4gYmUgdXNlZCB0byBjcmVhdGUgZW1iZWRkZWRWaWV3IG9uIHRoZSBmbHkuXG4gICAgLy8gU2VlIFRhYnNTZXJ2aWNlJ3MgcmVuZGVyVmlldygpIG1ldGhvZCBhbmQgaG93IGl0J3MgdXNlZCBpbiBUYWJzIGNsYXNzIGZvciBhbiBleGFtcGxlLlxuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmNmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShUZW1wbGF0ZVJlZkNvbnRhaW5lcik7XG4gICAgdGhpcy50ZW1wbGF0ZVJlZkNvbnRhaW5lciA9IHRoaXMudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFtcbiAgICAgIFt0aGlzLmVsLm5hdGl2ZUVsZW1lbnRdLFxuICAgIF0pLmluc3RhbmNlO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtY29udHJvbHMnKVxuICBnZXQgYXJpYUNvbnRyb2xzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUNvbnRyb2xzO1xuICB9XG5cbiAgZ2V0IHRhYkxpbmtJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFMYWJlbGxlZEJ5O1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdpZCcpXG4gIEBJbnB1dCgnaWQnKVxuICBzZXQgdGFiTGlua0lkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFMYWJlbGxlZEJ5ID0gaWQ7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPSB0aGlzLmlkO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hY3RpdmUnKVxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1zZWxlY3RlZCcpXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPT09IHRoaXMuaWQ7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICBnZXQgdGFiaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlID8gMCA6IC0xO1xuICB9XG59XG4iXX0=