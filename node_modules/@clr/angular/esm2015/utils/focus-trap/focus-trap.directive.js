import { __decorate, __param } from "tslib";
/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { AfterViewInit, Directive, ElementRef, HostListener, Inject, Injector, Input, OnDestroy, PLATFORM_ID, Renderer2, } from '@angular/core';
import { FocusTrapTracker } from './focus-trap-tracker.service';
let FocusTrapDirective = class FocusTrapDirective {
    constructor(el, injector, focusTrapsTracker, renderer, platformId) {
        this.el = el;
        this.injector = injector;
        this.focusTrapsTracker = focusTrapsTracker;
        this.renderer = renderer;
        this.platformId = platformId;
        this.localFocusEscaped = false;
        this._config = {
            strict: true,
        };
        this.document = this.injector.get(DOCUMENT);
        this.focusTrapsTracker.current = this;
        this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
    }
    set config(config) {
        this._config = Object.assign(this._config, config);
    }
    onFocusIn(event) {
        if (this.focusTrapsTracker.current !== this || !isPlatformBrowser(this.platformId) || this.localFocusEscaped) {
            return;
        }
        const nativeElement = this.el.nativeElement;
        if (this._config.strict && event.target && !nativeElement.contains(event.target)) {
            // When the focus trap is global, always steal focus back if it goes outside
            nativeElement.focus();
        }
        else if (event.target === this.bottomReboundEl && nativeElement.contains(this.previousTrappedActiveElement)) {
            // When the focus trap is local, if the user navigates via keyboard to the end element from within the trap, move to top
            nativeElement.focus();
        }
        else if (event.target === this.topReboundEl) {
            // When the focus trap is local, if the user navigates via keyboard back to start element from within the trap, move to bottom
            // @TODO implement an acceptable solution to SHIFT+TAB navigation
        }
        else if (event.target !== nativeElement && !nativeElement.contains(event.target)) {
            // If a user has escaped the trap using the mouse
            // relax, don't do it, when you want to go to it, living those dreams, scheme those schemes, hit me with those laser beams
            this.localFocusEscaped = true;
        }
        // Track the last focused item, so we can check
        this.previousTrappedActiveElement = event.target;
    }
    createFocusableOffScreenEl() {
        // Not using Renderer2's createElement method because that leads to DOM leakage.
        // https://github.com/angular/angular/issues/26954
        const offScreenSpan = this.document.createElement('span');
        this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
        this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
        return offScreenSpan;
    }
    addReboundEls() {
        if (isPlatformBrowser(this.platformId)) {
            this.topReboundEl = this.createFocusableOffScreenEl();
            this.bottomReboundEl = this.createFocusableOffScreenEl();
            const hostElement = this.el.nativeElement;
            // Add reboundBeforeTrapEl right outside of host element
            this.renderer.insertBefore(hostElement.parentElement, this.topReboundEl, hostElement);
            // Add reboundAfterTrapEl right after host element
            if (hostElement.nextSibling) {
                this.renderer.insertBefore(hostElement.parentNode, this.bottomReboundEl, hostElement.nextSibling);
            }
            else {
                this.renderer.appendChild(hostElement.parentNode, this.bottomReboundEl);
            }
        }
    }
    removeReboundEls() {
        if (isPlatformBrowser(this.platformId) && this.topReboundEl && this.bottomReboundEl) {
            this.parentElement.removeChild(this.topReboundEl);
            this.parentElement.removeChild(this.bottomReboundEl);
            // These are here to to make sure that
            // we completely delete all traces of the removed DOM objects.
            delete this.topReboundEl;
            delete this.bottomReboundEl;
        }
    }
    setPreviousFocus() {
        if (this.previousActiveElement && this.previousActiveElement.focus) {
            this.previousActiveElement.focus();
        }
    }
    ngAfterViewInit() {
        if (isPlatformBrowser(this.platformId)) {
            this.previousActiveElement = this.document.activeElement;
            this.parentElement = this.el.nativeElement.parentElement;
        }
        this.addReboundEls();
    }
    ngOnDestroy() {
        this.removeReboundEls();
        this.setPreviousFocus();
        this.focusTrapsTracker.activatePreviousTrapper();
    }
};
FocusTrapDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector },
    { type: FocusTrapTracker },
    { type: Renderer2 },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
__decorate([
    Input('clrFocusTrap')
], FocusTrapDirective.prototype, "config", null);
__decorate([
    HostListener('document:focusin', ['$event'])
], FocusTrapDirective.prototype, "onFocusIn", null);
FocusTrapDirective = __decorate([
    Directive({ selector: '[clrFocusTrap]' }),
    __param(4, Inject(PLATFORM_ID))
], FocusTrapDirective);
export { FocusTrapDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9jdXMtdHJhcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY2xyL2FuZ3VsYXIvIiwic291cmNlcyI6WyJ1dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHO0FBQ0gsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFDTCxhQUFhLEVBQ2IsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osTUFBTSxFQUNOLFFBQVEsRUFDUixLQUFLLEVBQ0wsU0FBUyxFQUNULFdBQVcsRUFDWCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFPaEUsSUFBYSxrQkFBa0IsR0FBL0IsTUFBYSxrQkFBa0I7SUFVN0IsWUFDVSxFQUFjLEVBQ2QsUUFBa0IsRUFDbEIsaUJBQW1DLEVBQ25DLFFBQW1CLEVBQ0UsVUFBa0I7UUFKdkMsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUNkLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFrQjtRQUNuQyxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ0UsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQVp6QyxzQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFvQjFCLFlBQU8sR0FBb0I7WUFDakMsTUFBTSxFQUFFLElBQUk7U0FDYixDQUFDO1FBUkEsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUV0QyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxVQUFV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O1lBQ2MsTUFBTSx1QkFBOUMsTUFBTSxTQUFDLFdBQVc7O0FBWXJCO0lBREMsS0FBSyxDQUFDLGNBQWMsQ0FBQztnREFHckI7QUFHRDtJQURDLFlBQVksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO21EQXNCNUM7QUFyRFUsa0JBQWtCO0lBRDlCLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO0lBZ0JyQyxXQUFBLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtHQWZYLGtCQUFrQixDQWdIOUI7U0FoSFksa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIEluamVjdG9yLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBQTEFURk9STV9JRCxcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRm9jdXNUcmFwVHJhY2tlciB9IGZyb20gJy4vZm9jdXMtdHJhcC10cmFja2VyLnNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgRm9jdXNUcmFwQ29uZmlnIHtcbiAgc3RyaWN0OiBib29sZWFuO1xufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyRm9jdXNUcmFwXScgfSlcbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXBEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHByZXZpb3VzQWN0aXZlRWxlbWVudDogYW55O1xuICBwcml2YXRlIHByZXZpb3VzVHJhcHBlZEFjdGl2ZUVsZW1lbnQ6IGFueTtcbiAgcHJpdmF0ZSBsb2NhbEZvY3VzRXNjYXBlZCA9IGZhbHNlO1xuICBwcml2YXRlIGRvY3VtZW50OiBEb2N1bWVudDtcbiAgcHJpdmF0ZSBwYXJlbnRFbGVtZW50OiBFbGVtZW50O1xuXG4gIHByaXZhdGUgdG9wUmVib3VuZEVsOiBhbnk7XG4gIHByaXZhdGUgYm90dG9tUmVib3VuZEVsOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBwcml2YXRlIGZvY3VzVHJhcHNUcmFja2VyOiBGb2N1c1RyYXBUcmFja2VyLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gdGhpcy5pbmplY3Rvci5nZXQoRE9DVU1FTlQpO1xuICAgIHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuY3VycmVudCA9IHRoaXM7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcsICcwJyk7XG4gIH1cblxuICBwcml2YXRlIF9jb25maWc6IEZvY3VzVHJhcENvbmZpZyA9IHtcbiAgICBzdHJpY3Q6IHRydWUsXG4gIH07XG4gIEBJbnB1dCgnY2xyRm9jdXNUcmFwJylcbiAgc2V0IGNvbmZpZyhjb25maWc6IEZvY3VzVHJhcENvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24odGhpcy5fY29uZmlnLCBjb25maWcpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Zm9jdXNpbicsIFsnJGV2ZW50J10pXG4gIG9uRm9jdXNJbihldmVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuY3VycmVudCAhPT0gdGhpcyB8fCAhaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSB8fCB0aGlzLmxvY2FsRm9jdXNFc2NhcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLl9jb25maWcuc3RyaWN0ICYmIGV2ZW50LnRhcmdldCAmJiAhbmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAvLyBXaGVuIHRoZSBmb2N1cyB0cmFwIGlzIGdsb2JhbCwgYWx3YXlzIHN0ZWFsIGZvY3VzIGJhY2sgaWYgaXQgZ29lcyBvdXRzaWRlXG4gICAgICBuYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuYm90dG9tUmVib3VuZEVsICYmIG5hdGl2ZUVsZW1lbnQuY29udGFpbnModGhpcy5wcmV2aW91c1RyYXBwZWRBY3RpdmVFbGVtZW50KSkge1xuICAgICAgLy8gV2hlbiB0aGUgZm9jdXMgdHJhcCBpcyBsb2NhbCwgaWYgdGhlIHVzZXIgbmF2aWdhdGVzIHZpYSBrZXlib2FyZCB0byB0aGUgZW5kIGVsZW1lbnQgZnJvbSB3aXRoaW4gdGhlIHRyYXAsIG1vdmUgdG8gdG9wXG4gICAgICBuYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMudG9wUmVib3VuZEVsKSB7XG4gICAgICAvLyBXaGVuIHRoZSBmb2N1cyB0cmFwIGlzIGxvY2FsLCBpZiB0aGUgdXNlciBuYXZpZ2F0ZXMgdmlhIGtleWJvYXJkIGJhY2sgdG8gc3RhcnQgZWxlbWVudCBmcm9tIHdpdGhpbiB0aGUgdHJhcCwgbW92ZSB0byBib3R0b21cbiAgICAgIC8vIEBUT0RPIGltcGxlbWVudCBhbiBhY2NlcHRhYmxlIHNvbHV0aW9uIHRvIFNISUZUK1RBQiBuYXZpZ2F0aW9uXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgIT09IG5hdGl2ZUVsZW1lbnQgJiYgIW5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgLy8gSWYgYSB1c2VyIGhhcyBlc2NhcGVkIHRoZSB0cmFwIHVzaW5nIHRoZSBtb3VzZVxuICAgICAgLy8gcmVsYXgsIGRvbid0IGRvIGl0LCB3aGVuIHlvdSB3YW50IHRvIGdvIHRvIGl0LCBsaXZpbmcgdGhvc2UgZHJlYW1zLCBzY2hlbWUgdGhvc2Ugc2NoZW1lcywgaGl0IG1lIHdpdGggdGhvc2UgbGFzZXIgYmVhbXNcbiAgICAgIHRoaXMubG9jYWxGb2N1c0VzY2FwZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBUcmFjayB0aGUgbGFzdCBmb2N1c2VkIGl0ZW0sIHNvIHdlIGNhbiBjaGVja1xuICAgIHRoaXMucHJldmlvdXNUcmFwcGVkQWN0aXZlRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTogYW55IHtcbiAgICAvLyBOb3QgdXNpbmcgUmVuZGVyZXIyJ3MgY3JlYXRlRWxlbWVudCBtZXRob2QgYmVjYXVzZSB0aGF0IGxlYWRzIHRvIERPTSBsZWFrYWdlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzI2OTU0XG4gICAgY29uc3Qgb2ZmU2NyZWVuU3BhbiA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKG9mZlNjcmVlblNwYW4sICd0YWJpbmRleCcsICcwJyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhvZmZTY3JlZW5TcGFuLCAnb2Zmc2NyZWVuLWZvY3VzLXJlYm91bmRlcicpO1xuXG4gICAgcmV0dXJuIG9mZlNjcmVlblNwYW47XG4gIH1cblxuICBwcml2YXRlIGFkZFJlYm91bmRFbHMoKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMudG9wUmVib3VuZEVsID0gdGhpcy5jcmVhdGVGb2N1c2FibGVPZmZTY3JlZW5FbCgpO1xuICAgICAgdGhpcy5ib3R0b21SZWJvdW5kRWwgPSB0aGlzLmNyZWF0ZUZvY3VzYWJsZU9mZlNjcmVlbkVsKCk7XG4gICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICAgIC8vIEFkZCByZWJvdW5kQmVmb3JlVHJhcEVsIHJpZ2h0IG91dHNpZGUgb2YgaG9zdCBlbGVtZW50XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydEJlZm9yZShob3N0RWxlbWVudC5wYXJlbnRFbGVtZW50LCB0aGlzLnRvcFJlYm91bmRFbCwgaG9zdEVsZW1lbnQpO1xuICAgICAgLy8gQWRkIHJlYm91bmRBZnRlclRyYXBFbCByaWdodCBhZnRlciBob3N0IGVsZW1lbnRcbiAgICAgIGlmIChob3N0RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmluc2VydEJlZm9yZShob3N0RWxlbWVudC5wYXJlbnROb2RlLCB0aGlzLmJvdHRvbVJlYm91bmRFbCwgaG9zdEVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZChob3N0RWxlbWVudC5wYXJlbnROb2RlLCB0aGlzLmJvdHRvbVJlYm91bmRFbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVSZWJvdW5kRWxzKCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIHRoaXMudG9wUmVib3VuZEVsICYmIHRoaXMuYm90dG9tUmVib3VuZEVsKSB7XG4gICAgICB0aGlzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy50b3BSZWJvdW5kRWwpO1xuICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuYm90dG9tUmVib3VuZEVsKTtcbiAgICAgIC8vIFRoZXNlIGFyZSBoZXJlIHRvIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyB3ZSBjb21wbGV0ZWx5IGRlbGV0ZSBhbGwgdHJhY2VzIG9mIHRoZSByZW1vdmVkIERPTSBvYmplY3RzLlxuICAgICAgZGVsZXRlIHRoaXMudG9wUmVib3VuZEVsO1xuICAgICAgZGVsZXRlIHRoaXMuYm90dG9tUmVib3VuZEVsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRQcmV2aW91c0ZvY3VzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudCAmJiB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cykge1xuICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gPEhUTUxFbGVtZW50PnRoaXMuZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIHRoaXMuYWRkUmVib3VuZEVscygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSZWJvdW5kRWxzKCk7XG4gICAgdGhpcy5zZXRQcmV2aW91c0ZvY3VzKCk7XG4gICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5hY3RpdmF0ZVByZXZpb3VzVHJhcHBlcigpO1xuICB9XG59XG4iXX0=