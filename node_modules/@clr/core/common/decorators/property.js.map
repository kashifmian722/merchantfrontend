{"version":3,"file":"property.js","sourceRoot":"","sources":["../../../../src/clr-core/common/decorators/property.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,2BAA2B;AAC3B,OAAO,EAAE,QAAQ,IAAI,IAAI,EAAE,MAAM,aAAa,CAAC;AAC/C,OAAO,EAAE,oBAAoB,EAAE,MAAM,iBAAiB,CAAC;AAEvD;;;;;;;GAOG;AACH,MAAM,UAAU,QAAQ,CAAC,OAA+C;IACtE,OAAO,CAAC,iBAAqB,EAAE,IAAY,EAAE,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;AAClH,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,iBAAiB,CAC/B,WAAmB,EACnB,OAA+C;IAE/C,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC;IAE9C,QAAQ,IAAI,EAAE;QACZ,KAAK,KAAK;YACR,uBAAS,OAAO,EAAE,KAAK,IAAK,OAAO,EAAG;QACxC,KAAK,MAAM;YACT,uBAAS,OAAO,EAAE,KAAK,IAAK,OAAO,EAAG;QACxC,KAAK,MAAM;YACT,uBACE,OAAO,EAAE,IAAI,EACb,SAAS,EAAE,oBAAoB,CAAC,WAAW,CAAC,EAC5C,SAAS,EAAE;oBACT,WAAW,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;iBACzD,IACE,OAAO,EACV;QACJ,KAAK,MAAM;YACT,uBAAS,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,oBAAoB,CAAC,WAAW,CAAC,IAAK,OAAO,EAAG;QACrF,KAAK,OAAO;YACV,uBACE,OAAO,EAAE,IAAI,EACb,SAAS,EAAE,oBAAoB,CAAC,WAAW,CAAC,EAC5C,SAAS,EAAE;oBACT,4EAA4E;oBAC5E,sFAAsF;oBACtF,aAAa,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK,KAAK,OAAO;iBACpD,IACE,OAAO,EACV;QACJ,KAAK,IAAI,CAAC,CAAC;YACT;gBACE,4EAA4E;gBAC5E,OAAO,EAAE,KAAK,EACd,SAAS,EAAE;oBACT,aAAa,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC;iBAClD,IACE,OAAO,EACV;SACH;QACD;YACE,OAAO,OAAgD,CAAC;KAC3D;AACH,CAAC","sourcesContent":["/*\n * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.\n * This software is released under MIT license.\n * The full license information can be found in LICENSE in the root directory of this project.\n */\n\n// tslint:disable-next-line\nimport { property as prop } from 'lit-element';\nimport { camelCaseToKebabCase } from '../utils/string';\n\n/**\n * lit-element @property decorator with custom defaults.\n * https://lit-element.polymer-project.org/guide/properties#property-options\n *\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A PropertyDeclaration may optionally be\n * supplied to configure property features.\n */\nexport function property(options?: PropertyDeclaration<unknown, unknown>) {\n  return (protoOrDescriptor: {}, name: string) => prop(getDefaultOptions(name, options))(protoOrDescriptor, name);\n}\n\n/**\n * https://developers.google.com/web/fundamentals/web-components/best-practices\n */\nexport function getDefaultOptions(\n  propertyKey: string,\n  options?: PropertyDeclaration<unknown, unknown>\n): PropertyDeclaration {\n  const type = options ? options.type : options;\n\n  switch (type) {\n    case Array:\n      return { reflect: false, ...options };\n    case Object:\n      return { reflect: false, ...options };\n    case String:\n      return {\n        reflect: true,\n        attribute: camelCaseToKebabCase(propertyKey),\n        converter: {\n          toAttribute: (value: string) => (!!value ? value : null),\n        },\n        ...options,\n      };\n    case Number:\n      return { reflect: true, attribute: camelCaseToKebabCase(propertyKey), ...options };\n    case Boolean:\n      return {\n        reflect: true,\n        attribute: camelCaseToKebabCase(propertyKey),\n        converter: {\n          // Mimic standard HTML boolean attributes + support \"false\" attribute values\n          // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n          fromAttribute: (value: string) => value !== 'false',\n        },\n        ...options,\n      };\n    case Date: {\n      return {\n        // Parse date strings from attributes but do not reflect back into attribute\n        reflect: false,\n        converter: {\n          fromAttribute: (value: string) => new Date(value),\n        },\n        ...options,\n      };\n    }\n    default:\n      return options as PropertyDeclaration<unknown, unknown>;\n  }\n}\n\nexport interface PropertyDeclaration<Type = unknown, TypeHint = unknown> {\n  noAccessor?: boolean;\n  attribute?: boolean | string;\n  type?: TypeHint;\n  reflect?: boolean;\n  converter?:\n    | ((value: string, type?: TypeHint) => Type)\n    | {\n        fromAttribute?(value: string | null, type?: TypeHint): Type;\n        toAttribute?(value: Type, type?: TypeHint): unknown;\n      };\n  hasChanged?(value: Type, oldValue: Type): boolean;\n}\n"]}