import { __decorate, __param } from "tslib";
/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { AfterViewInit, Directive, ElementRef, HostListener, Inject, Injector, Input, OnDestroy, PLATFORM_ID, Renderer2, } from '@angular/core';
import { FocusTrapTracker } from './focus-trap-tracker.service';
var FocusTrapDirective = /** @class */ (function () {
    function FocusTrapDirective(el, injector, focusTrapsTracker, renderer, platformId) {
        this.el = el;
        this.injector = injector;
        this.focusTrapsTracker = focusTrapsTracker;
        this.renderer = renderer;
        this.platformId = platformId;
        this.localFocusEscaped = false;
        this._config = {
            strict: true,
        };
        this.document = this.injector.get(DOCUMENT);
        this.focusTrapsTracker.current = this;
        this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
    }
    Object.defineProperty(FocusTrapDirective.prototype, "config", {
        set: function (config) {
            this._config = Object.assign(this._config, config);
        },
        enumerable: true,
        configurable: true
    });
    FocusTrapDirective.prototype.onFocusIn = function (event) {
        if (this.focusTrapsTracker.current !== this || !isPlatformBrowser(this.platformId) || this.localFocusEscaped) {
            return;
        }
        var nativeElement = this.el.nativeElement;
        if (this._config.strict && event.target && !nativeElement.contains(event.target)) {
            // When the focus trap is global, always steal focus back if it goes outside
            nativeElement.focus();
        }
        else if (event.target === this.bottomReboundEl && nativeElement.contains(this.previousTrappedActiveElement)) {
            // When the focus trap is local, if the user navigates via keyboard to the end element from within the trap, move to top
            nativeElement.focus();
        }
        else if (event.target === this.topReboundEl) {
            // When the focus trap is local, if the user navigates via keyboard back to start element from within the trap, move to bottom
            // @TODO implement an acceptable solution to SHIFT+TAB navigation
        }
        else if (event.target !== nativeElement && !nativeElement.contains(event.target)) {
            // If a user has escaped the trap using the mouse
            // relax, don't do it, when you want to go to it, living those dreams, scheme those schemes, hit me with those laser beams
            this.localFocusEscaped = true;
        }
        // Track the last focused item, so we can check
        this.previousTrappedActiveElement = event.target;
    };
    FocusTrapDirective.prototype.createFocusableOffScreenEl = function () {
        // Not using Renderer2's createElement method because that leads to DOM leakage.
        // https://github.com/angular/angular/issues/26954
        var offScreenSpan = this.document.createElement('span');
        this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
        this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
        return offScreenSpan;
    };
    FocusTrapDirective.prototype.addReboundEls = function () {
        if (isPlatformBrowser(this.platformId)) {
            this.topReboundEl = this.createFocusableOffScreenEl();
            this.bottomReboundEl = this.createFocusableOffScreenEl();
            var hostElement = this.el.nativeElement;
            // Add reboundBeforeTrapEl right outside of host element
            this.renderer.insertBefore(hostElement.parentElement, this.topReboundEl, hostElement);
            // Add reboundAfterTrapEl right after host element
            if (hostElement.nextSibling) {
                this.renderer.insertBefore(hostElement.parentNode, this.bottomReboundEl, hostElement.nextSibling);
            }
            else {
                this.renderer.appendChild(hostElement.parentNode, this.bottomReboundEl);
            }
        }
    };
    FocusTrapDirective.prototype.removeReboundEls = function () {
        if (isPlatformBrowser(this.platformId) && this.topReboundEl && this.bottomReboundEl) {
            this.parentElement.removeChild(this.topReboundEl);
            this.parentElement.removeChild(this.bottomReboundEl);
            // These are here to to make sure that
            // we completely delete all traces of the removed DOM objects.
            delete this.topReboundEl;
            delete this.bottomReboundEl;
        }
    };
    FocusTrapDirective.prototype.setPreviousFocus = function () {
        if (this.previousActiveElement && this.previousActiveElement.focus) {
            this.previousActiveElement.focus();
        }
    };
    FocusTrapDirective.prototype.ngAfterViewInit = function () {
        if (isPlatformBrowser(this.platformId)) {
            this.previousActiveElement = this.document.activeElement;
            this.parentElement = this.el.nativeElement.parentElement;
        }
        this.addReboundEls();
    };
    FocusTrapDirective.prototype.ngOnDestroy = function () {
        this.removeReboundEls();
        this.setPreviousFocus();
        this.focusTrapsTracker.activatePreviousTrapper();
    };
    FocusTrapDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Injector },
        { type: FocusTrapTracker },
        { type: Renderer2 },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    __decorate([
        Input('clrFocusTrap')
    ], FocusTrapDirective.prototype, "config", null);
    __decorate([
        HostListener('document:focusin', ['$event'])
    ], FocusTrapDirective.prototype, "onFocusIn", null);
    FocusTrapDirective = __decorate([
        Directive({ selector: '[clrFocusTrap]' }),
        __param(4, Inject(PLATFORM_ID))
    ], FocusTrapDirective);
    return FocusTrapDirective;
}());
export { FocusTrapDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9jdXMtdHJhcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY2xyL2FuZ3VsYXIvIiwic291cmNlcyI6WyJ1dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHO0FBQ0gsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFDTCxhQUFhLEVBQ2IsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osTUFBTSxFQUNOLFFBQVEsRUFDUixLQUFLLEVBQ0wsU0FBUyxFQUNULFdBQVcsRUFDWCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFPaEU7SUFVRSw0QkFDVSxFQUFjLEVBQ2QsUUFBa0IsRUFDbEIsaUJBQW1DLEVBQ25DLFFBQW1CLEVBQ0UsVUFBa0I7UUFKdkMsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUNkLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFrQjtRQUNuQyxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ0UsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQVp6QyxzQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFvQjFCLFlBQU8sR0FBb0I7WUFDakMsTUFBTSxFQUFFLElBQUk7U0FDYixDQUFDO1FBUkEsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUV0QyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxVQUFVLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDckUsQ0FB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QkFBZ0I7Z0JBQ3pCLFNBQVM7Z0JBQ2MsTUFBTSx1QkFBOUMsTUFBTSxTQUFDLFdBQVc7O0lBWXJCO1FBREMsS0FBSyxDQUFDLGNBQWMsQ0FBQztvREFHckI7SUFHRDtRQURDLFlBQVksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3VEQXNCNUM7SUFyRFUsa0JBQWtCO1FBRDlCLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO1FBZ0JyQyxXQUFBLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtPQWZYLGtCQUFrQixDQWdIOUI7SUFBRCx5QkFBQztDQUFBLEFBaEhELElBZ0hDO1NBaEhZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUExBVEZPUk1fSUQsXG4gIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZvY3VzVHJhcFRyYWNrZXIgfSBmcm9tICcuL2ZvY3VzLXRyYXAtdHJhY2tlci5zZXJ2aWNlJztcblxuaW50ZXJmYWNlIEZvY3VzVHJhcENvbmZpZyB7XG4gIHN0cmljdDogYm9vbGVhbjtcbn1cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckZvY3VzVHJhcF0nIH0pXG5leHBvcnQgY2xhc3MgRm9jdXNUcmFwRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBwcmV2aW91c0FjdGl2ZUVsZW1lbnQ6IGFueTtcbiAgcHJpdmF0ZSBwcmV2aW91c1RyYXBwZWRBY3RpdmVFbGVtZW50OiBhbnk7XG4gIHByaXZhdGUgbG9jYWxGb2N1c0VzY2FwZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQ7XG4gIHByaXZhdGUgcGFyZW50RWxlbWVudDogRWxlbWVudDtcblxuICBwcml2YXRlIHRvcFJlYm91bmRFbDogYW55O1xuICBwcml2YXRlIGJvdHRvbVJlYm91bmRFbDogYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBmb2N1c1RyYXBzVHJhY2tlcjogRm9jdXNUcmFwVHJhY2tlcixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3RcbiAgKSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IHRoaXMuaW5qZWN0b3IuZ2V0KERPQ1VNRU5UKTtcbiAgICB0aGlzLmZvY3VzVHJhcHNUcmFja2VyLmN1cnJlbnQgPSB0aGlzO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndGFiaW5kZXgnLCAnMCcpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29uZmlnOiBGb2N1c1RyYXBDb25maWcgPSB7XG4gICAgc3RyaWN0OiB0cnVlLFxuICB9O1xuICBASW5wdXQoJ2NsckZvY3VzVHJhcCcpXG4gIHNldCBjb25maWcoY29uZmlnOiBGb2N1c1RyYXBDb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBPYmplY3QuYXNzaWduKHRoaXMuX2NvbmZpZywgY29uZmlnKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IGFueSkge1xuICAgIGlmICh0aGlzLmZvY3VzVHJhcHNUcmFja2VyLmN1cnJlbnQgIT09IHRoaXMgfHwgIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgfHwgdGhpcy5sb2NhbEZvY3VzRXNjYXBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICBpZiAodGhpcy5fY29uZmlnLnN0cmljdCAmJiBldmVudC50YXJnZXQgJiYgIW5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgLy8gV2hlbiB0aGUgZm9jdXMgdHJhcCBpcyBnbG9iYWwsIGFsd2F5cyBzdGVhbCBmb2N1cyBiYWNrIGlmIGl0IGdvZXMgb3V0c2lkZVxuICAgICAgbmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmJvdHRvbVJlYm91bmRFbCAmJiBuYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMucHJldmlvdXNUcmFwcGVkQWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIC8vIFdoZW4gdGhlIGZvY3VzIHRyYXAgaXMgbG9jYWwsIGlmIHRoZSB1c2VyIG5hdmlnYXRlcyB2aWEga2V5Ym9hcmQgdG8gdGhlIGVuZCBlbGVtZW50IGZyb20gd2l0aGluIHRoZSB0cmFwLCBtb3ZlIHRvIHRvcFxuICAgICAgbmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLnRvcFJlYm91bmRFbCkge1xuICAgICAgLy8gV2hlbiB0aGUgZm9jdXMgdHJhcCBpcyBsb2NhbCwgaWYgdGhlIHVzZXIgbmF2aWdhdGVzIHZpYSBrZXlib2FyZCBiYWNrIHRvIHN0YXJ0IGVsZW1lbnQgZnJvbSB3aXRoaW4gdGhlIHRyYXAsIG1vdmUgdG8gYm90dG9tXG4gICAgICAvLyBAVE9ETyBpbXBsZW1lbnQgYW4gYWNjZXB0YWJsZSBzb2x1dGlvbiB0byBTSElGVCtUQUIgbmF2aWdhdGlvblxuICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ICE9PSBuYXRpdmVFbGVtZW50ICYmICFuYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIGEgdXNlciBoYXMgZXNjYXBlZCB0aGUgdHJhcCB1c2luZyB0aGUgbW91c2VcbiAgICAgIC8vIHJlbGF4LCBkb24ndCBkbyBpdCwgd2hlbiB5b3Ugd2FudCB0byBnbyB0byBpdCwgbGl2aW5nIHRob3NlIGRyZWFtcywgc2NoZW1lIHRob3NlIHNjaGVtZXMsIGhpdCBtZSB3aXRoIHRob3NlIGxhc2VyIGJlYW1zXG4gICAgICB0aGlzLmxvY2FsRm9jdXNFc2NhcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJhY2sgdGhlIGxhc3QgZm9jdXNlZCBpdGVtLCBzbyB3ZSBjYW4gY2hlY2tcbiAgICB0aGlzLnByZXZpb3VzVHJhcHBlZEFjdGl2ZUVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUZvY3VzYWJsZU9mZlNjcmVlbkVsKCk6IGFueSB7XG4gICAgLy8gTm90IHVzaW5nIFJlbmRlcmVyMidzIGNyZWF0ZUVsZW1lbnQgbWV0aG9kIGJlY2F1c2UgdGhhdCBsZWFkcyB0byBET00gbGVha2FnZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yNjk1NFxuICAgIGNvbnN0IG9mZlNjcmVlblNwYW4gPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShvZmZTY3JlZW5TcGFuLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3Mob2ZmU2NyZWVuU3BhbiwgJ29mZnNjcmVlbi1mb2N1cy1yZWJvdW5kZXInKTtcblxuICAgIHJldHVybiBvZmZTY3JlZW5TcGFuO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRSZWJvdW5kRWxzKCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLnRvcFJlYm91bmRFbCA9IHRoaXMuY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTtcbiAgICAgIHRoaXMuYm90dG9tUmVib3VuZEVsID0gdGhpcy5jcmVhdGVGb2N1c2FibGVPZmZTY3JlZW5FbCgpO1xuICAgICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAvLyBBZGQgcmVib3VuZEJlZm9yZVRyYXBFbCByaWdodCBvdXRzaWRlIG9mIGhvc3QgZWxlbWVudFxuICAgICAgdGhpcy5yZW5kZXJlci5pbnNlcnRCZWZvcmUoaG9zdEVsZW1lbnQucGFyZW50RWxlbWVudCwgdGhpcy50b3BSZWJvdW5kRWwsIGhvc3RFbGVtZW50KTtcbiAgICAgIC8vIEFkZCByZWJvdW5kQWZ0ZXJUcmFwRWwgcmlnaHQgYWZ0ZXIgaG9zdCBlbGVtZW50XG4gICAgICBpZiAoaG9zdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5pbnNlcnRCZWZvcmUoaG9zdEVsZW1lbnQucGFyZW50Tm9kZSwgdGhpcy5ib3R0b21SZWJvdW5kRWwsIGhvc3RFbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQoaG9zdEVsZW1lbnQucGFyZW50Tm9kZSwgdGhpcy5ib3R0b21SZWJvdW5kRWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlUmVib3VuZEVscygpIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLnRvcFJlYm91bmRFbCAmJiB0aGlzLmJvdHRvbVJlYm91bmRFbCkge1xuICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMudG9wUmVib3VuZEVsKTtcbiAgICAgIHRoaXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmJvdHRvbVJlYm91bmRFbCk7XG4gICAgICAvLyBUaGVzZSBhcmUgaGVyZSB0byB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgLy8gd2UgY29tcGxldGVseSBkZWxldGUgYWxsIHRyYWNlcyBvZiB0aGUgcmVtb3ZlZCBET00gb2JqZWN0cy5cbiAgICAgIGRlbGV0ZSB0aGlzLnRvcFJlYm91bmRFbDtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvdHRvbVJlYm91bmRFbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0UHJldmlvdXNGb2N1cygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgJiYgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IDxIVE1MRWxlbWVudD50aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFJlYm91bmRFbHMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlUmVib3VuZEVscygpO1xuICAgIHRoaXMuc2V0UHJldmlvdXNGb2N1cygpO1xuICAgIHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuYWN0aXZhdGVQcmV2aW91c1RyYXBwZXIoKTtcbiAgfVxufVxuIl19