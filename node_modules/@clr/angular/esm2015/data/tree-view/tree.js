/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { AfterContentInit, Component, ContentChildren, ElementRef, HostListener, Input, OnDestroy, QueryList, } from '@angular/core';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNode } from './tree-node';
let ClrTree = class ClrTree {
    constructor(featuresService, focusManagerService, el) {
        this.featuresService = featuresService;
        this.focusManagerService = focusManagerService;
        this.el = el;
        this.subscriptions = [];
        this.tabindex = 0;
    }
    set lazy(value) {
        this.featuresService.eager = !value;
    }
    get isMultiSelectable() {
        return this.featuresService.selectable && this.rootNodes.length > 0;
    }
    onFocusIn(event) {
        if (event.target === this.el.nativeElement) {
            // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
            // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
            this.focusManagerService.focusFirstVisibleNode();
            // when the first child gets focus,
            // tree should no longer have tabindex of 0;
            delete this.tabindex;
        }
    }
    ngAfterContentInit() {
        this.setRootNodes();
        this.subscriptions.push(this.rootNodes.changes.subscribe(() => {
            this.setRootNodes();
        }));
    }
    setRootNodes() {
        // if node has no parent, it's a root node
        // for recursive tree, this.rootNodes registers also nested children
        // so we have to use filter to extract the ones that are truly root nodes
        this.focusManagerService.rootNodeModels = this.rootNodes.map(node => node._model).filter(node => !node.parent);
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
};
ClrTree.ctorParameters = () => [
    { type: TreeFeaturesService },
    { type: TreeFocusManagerService },
    { type: ElementRef }
];
__decorate([
    Input('clrLazy')
], ClrTree.prototype, "lazy", null);
__decorate([
    HostListener('focusin', ['$event'])
], ClrTree.prototype, "onFocusIn", null);
__decorate([
    ContentChildren(ClrTreeNode)
], ClrTree.prototype, "rootNodes", void 0);
ClrTree = __decorate([
    Component({
        selector: 'clr-tree',
        template: `
    <ng-content></ng-content>
    <clr-recursive-children *ngIf="featuresService.recursion"
                            [children]="featuresService.recursion.root"></clr-recursive-children>
  `,
        providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
        host: {
            '[attr.tabindex]': 'tabindex',
            '[attr.role]': '"tree"',
            '[attr.aria-multiselectable]': 'isMultiSelectable',
        }
    })
], ClrTree);
export { ClrTree };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjbHIvYW5ndWxhci8iLCJzb3VyY2VzIjpbImRhdGEvdHJlZS12aWV3L3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRzs7QUFFSCxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN2RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN0RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBZ0IxQyxJQUFhLE9BQU8sR0FBcEIsTUFBYSxPQUFPO0lBQ2xCLFlBQ1MsZUFBdUMsRUFDdEMsbUJBQStDLEVBQy9DLEVBQWM7UUFGZixvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7UUFDdEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUE0QjtRQUMvQyxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBR2hCLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztRQU8zQyxhQUFRLEdBQUcsQ0FBQyxDQUFDO0lBVFYsQ0FBQztJQUtKLElBQUksSUFBSSxDQUFDLEtBQWM7UUFDckIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUM7SUFDdEMsQ0FBQztJQUlELElBQUksaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFHRCxTQUFTLENBQUMsS0FBaUI7UUFDekIsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFO1lBQzFDLDZIQUE2SDtZQUM3SCxxSEFBcUg7WUFDckgsSUFBSSxDQUFDLG1CQUFtQixDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFFakQsbUNBQW1DO1lBQ25DLDRDQUE0QztZQUM1QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBSUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNwQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNwQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTyxZQUFZO1FBQ2xCLDBDQUEwQztRQUMxQyxvRUFBb0U7UUFDcEUseUVBQXlFO1FBQ3pFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakgsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7Q0FDRixDQUFBOztZQXBEMkIsbUJBQW1CO1lBQ2QsdUJBQXVCO1lBQ3hDLFVBQVU7O0FBTXhCO0lBREMsS0FBSyxDQUFDLFNBQVMsQ0FBQzttQ0FHaEI7QUFTRDtJQURDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzt3Q0FXbkM7QUFFNkI7SUFBN0IsZUFBZSxDQUFDLFdBQVcsQ0FBQzswQ0FBOEM7QUFqQ2hFLE9BQU87SUFkbkIsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLFVBQVU7UUFDcEIsUUFBUSxFQUFFOzs7O0dBSVQ7UUFDRCxTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSx1QkFBdUIsQ0FBQztRQUM1RCxJQUFJLEVBQUU7WUFDSixpQkFBaUIsRUFBRSxVQUFVO1lBQzdCLGFBQWEsRUFBRSxRQUFRO1lBQ3ZCLDZCQUE2QixFQUFFLG1CQUFtQjtTQUNuRDtLQUNGLENBQUM7R0FDVyxPQUFPLENBc0RuQjtTQXREWSxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE5IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vdHJlZS1mb2N1cy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSwgVFJFRV9GRUFUVVJFU19QUk9WSURFUiB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRyZWVOb2RlIH0gZnJvbSAnLi90cmVlLW5vZGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdHJlZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxjbHItcmVjdXJzaXZlLWNoaWxkcmVuICpuZ0lmPVwiZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NoaWxkcmVuXT1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24ucm9vdFwiPjwvY2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbj5cbiAgYCxcbiAgcHJvdmlkZXJzOiBbVFJFRV9GRUFUVVJFU19QUk9WSURFUiwgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJpbmRleCcsXG4gICAgJ1thdHRyLnJvbGVdJzogJ1widHJlZVwiJyxcbiAgICAnW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdJzogJ2lzTXVsdGlTZWxlY3RhYmxlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBmb2N1c01hbmFnZXJTZXJ2aWNlOiBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmXG4gICkge31cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJMYXp5JylcbiAgc2V0IGxhenkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciA9ICF2YWx1ZTtcbiAgfVxuXG4gIHRhYmluZGV4ID0gMDtcblxuICBnZXQgaXNNdWx0aVNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgJiYgdGhpcy5yb290Tm9kZXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IEZvY3VzRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgIC8vIEFmdGVyIGRpc2N1c3Npbmcgd2l0aCB0aGUgdGVhbSwgSSd2ZSBtYWRlIGl0IHNvIHRoYXQgd2hlbiB0aGUgdHJlZSByZWNlaXZlcyBmb2N1cywgdGhlIGZpcnN0IHZpc2libGUgbm9kZSB3aWxsIGJlIGZvY3VzZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBmcm9tIHRoZSBwYWdlIHNjcm9sbGluZyBhYnJ1cHRseSB0byB0aGUgZmlyc3Qgc2VsZWN0ZWQgbm9kZSBpZiBpdCBleGlzdCBpbiBhIGRlZXBseSBuZXN0ZWQgdHJlZS5cbiAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcblxuICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgY2hpbGQgZ2V0cyBmb2N1cyxcbiAgICAgIC8vIHRyZWUgc2hvdWxkIG5vIGxvbmdlciBoYXZlIHRhYmluZGV4IG9mIDA7XG4gICAgICBkZWxldGUgdGhpcy50YWJpbmRleDtcbiAgICB9XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKENsclRyZWVOb2RlKSBwcml2YXRlIHJvb3ROb2RlczogUXVlcnlMaXN0PENsclRyZWVOb2RlPFQ+PjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucm9vdE5vZGVzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRSb290Tm9kZXMoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Um9vdE5vZGVzKCk6IHZvaWQge1xuICAgIC8vIGlmIG5vZGUgaGFzIG5vIHBhcmVudCwgaXQncyBhIHJvb3Qgbm9kZVxuICAgIC8vIGZvciByZWN1cnNpdmUgdHJlZSwgdGhpcy5yb290Tm9kZXMgcmVnaXN0ZXJzIGFsc28gbmVzdGVkIGNoaWxkcmVuXG4gICAgLy8gc28gd2UgaGF2ZSB0byB1c2UgZmlsdGVyIHRvIGV4dHJhY3QgdGhlIG9uZXMgdGhhdCBhcmUgdHJ1bHkgcm9vdCBub2Rlc1xuICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5yb290Tm9kZU1vZGVscyA9IHRoaXMucm9vdE5vZGVzLm1hcChub2RlID0+IG5vZGUuX21vZGVsKS5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIl19