import { EventEmitter, OnDestroy, OnInit, ViewContainerRef, ChangeDetectorRef, SimpleChanges, OnChanges } from '@angular/core';
import { ClrDatagridSortOrder } from './enums/sort-order.enum';
import { ClrDatagridComparatorInterface } from './interfaces/comparator.interface';
import { FiltersProvider } from './providers/filters';
import { Sort } from './providers/sort';
import { DatagridFilterRegistrar } from './utils/datagrid-filter-registrar';
import { ClrDatagridFilterInterface } from './interfaces/filter.interface';
import { ClrCommonStringsService } from '../../utils/i18n/common-strings.service';
import { DetailService } from './providers/detail.service';
import * as ɵngcc0 from '@angular/core';
export declare class ClrDatagridColumn<T = any> extends DatagridFilterRegistrar<T, ClrDatagridFilterInterface<T>> implements OnDestroy, OnInit, OnChanges {
    private _sort;
    private vcr;
    private detailService;
    private changeDetectorRef;
    commonStrings: ClrCommonStringsService;
    constructor(_sort: Sort<T>, filters: FiltersProvider<T>, vcr: ViewContainerRef, detailService: DetailService, changeDetectorRef: ChangeDetectorRef, commonStrings: ClrCommonStringsService);
    showSeparator: boolean;
    /**
     * Subscription to the sort service changes
     */
    private subscriptions;
    ngOnDestroy(): void;
    private listenForDetailPaneChanges;
    private listenForSortingChanges;
    private _field;
    get field(): string;
    private _colType;
    get colType(): 'string' | 'number';
    set colType(value: 'string' | 'number');
    set field(field: string);
    private setupDefaultFilter;
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * ClrDatagridComparatorInterface to use when sorting the column
     */
    private _sortBy;
    get sortBy(): ClrDatagridComparatorInterface<T> | string;
    set sortBy(comparator: ClrDatagridComparatorInterface<T> | string);
    /**
     * Indicates if the column is sortable
     */
    get sortable(): boolean;
    /**
     * Indicates if the column is currently sorted
     *
     * @deprecated This will be removed soon, in favor of the sortOrder mechanism
     */
    private _sorted;
    get sorted(): boolean;
    /**
     * @deprecated This will be removed soon, in favor of the sortOrder mechanism
     */
    set sorted(value: boolean);
    /**
     * @deprecated This will be removed soon, in favor of the sortOrder mechanism
     */
    sortedChange: EventEmitter<boolean>;
    /**
     * Indicates how the column is currently sorted
     */
    private _sortOrder;
    get sortOrder(): ClrDatagridSortOrder;
    set sortOrder(value: ClrDatagridSortOrder);
    get ariaSort(): "none" | "ascending" | "descending";
    sortOrderChange: EventEmitter<ClrDatagridSortOrder>;
    sortIcon: string;
    /**
     * Sorts the datagrid based on this column
     */
    sort(reverse?: boolean): void;
    /**
     * A custom filter for this column that can be provided in the projected content
     */
    customFilter: boolean;
    set projectedFilter(custom: any);
    private initFilterValue;
    get filterValue(): string | [number, number];
    set updateFilterValue(newValue: string | [number, number]);
    set filterValue(newValue: string | [number, number]);
    filterValueChange: EventEmitter<any>;
    private wrappedInjector;
    ngOnInit(): void;
    get _view(): any;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ClrDatagridColumn<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ClrDatagridColumn<any>, "clr-dg-column", never, {
    "field": "clrDgField";
    "colType": "clrDgColType";
    "updateFilterValue": "clrFilterValue";
    "sortBy": "clrDgSortBy";
    "sorted": "clrDgSorted";
    "sortOrder": "clrDgSortOrder";
}, {
    "sortedChange": "clrDgSortedChange";
    "sortOrderChange": "clrDgSortOrderChange";
    "filterValueChange": "clrFilterValueChange";
}, ["projectedFilter"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWdyaWQtY29sdW1uLmQudHMiLCJzb3VyY2VzIjpbImRhdGFncmlkLWNvbHVtbi5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCwgVmlld0NvbnRhaW5lclJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFNpbXBsZUNoYW5nZXMsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTb3J0T3JkZXIgfSBmcm9tICcuL2VudW1zL3NvcnQtb3JkZXIuZW51bSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZmlsdGVycyc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9wcm92aWRlcnMvc29ydCc7XG5pbXBvcnQgeyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhciB9IGZyb20gJy4vdXRpbHMvZGF0YWdyaWQtZmlsdGVyLXJlZ2lzdHJhcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcbmltcG9ydCB7IERldGFpbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kZXRhaWwuc2VydmljZSc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDbHJEYXRhZ3JpZENvbHVtbjxUID0gYW55PiBleHRlbmRzIERhdGFncmlkRmlsdGVyUmVnaXN0cmFyPFQsIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0LCBPbkNoYW5nZXMge1xuICAgIHByaXZhdGUgX3NvcnQ7XG4gICAgcHJpdmF0ZSB2Y3I7XG4gICAgcHJpdmF0ZSBkZXRhaWxTZXJ2aWNlO1xuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2U7XG4gICAgY29uc3RydWN0b3IoX3NvcnQ6IFNvcnQ8VD4sIGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPiwgdmNyOiBWaWV3Q29udGFpbmVyUmVmLCBkZXRhaWxTZXJ2aWNlOiBEZXRhaWxTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlKTtcbiAgICBzaG93U2VwYXJhdG9yOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgc29ydCBzZXJ2aWNlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBwcml2YXRlIGxpc3RlbkZvckRldGFpbFBhbmVDaGFuZ2VzO1xuICAgIHByaXZhdGUgbGlzdGVuRm9yU29ydGluZ0NoYW5nZXM7XG4gICAgcHJpdmF0ZSBfZmllbGQ7XG4gICAgZ2V0IGZpZWxkKCk6IHN0cmluZztcbiAgICBwcml2YXRlIF9jb2xUeXBlO1xuICAgIGdldCBjb2xUeXBlKCk6ICdzdHJpbmcnIHwgJ251bWJlcic7XG4gICAgc2V0IGNvbFR5cGUodmFsdWU6ICdzdHJpbmcnIHwgJ251bWJlcicpO1xuICAgIHNldCBmaWVsZChmaWVsZDogc3RyaW5nKTtcbiAgICBwcml2YXRlIHNldHVwRGVmYXVsdEZpbHRlcjtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgdG8gdXNlIHdoZW4gc29ydGluZyB0aGUgY29sdW1uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc29ydEJ5O1xuICAgIGdldCBzb3J0QnkoKTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+IHwgc3RyaW5nO1xuICAgIHNldCBzb3J0QnkoY29tcGFyYXRvcjogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+IHwgc3RyaW5nKTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZVxuICAgICAqL1xuICAgIGdldCBzb3J0YWJsZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWRcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc29ydGVkO1xuICAgIGdldCBzb3J0ZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBzb29uLCBpbiBmYXZvciBvZiB0aGUgc29ydE9yZGVyIG1lY2hhbmlzbVxuICAgICAqL1xuICAgIHNldCBzb3J0ZWQodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAgICovXG4gICAgc29ydGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGhvdyB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zb3J0T3JkZXI7XG4gICAgZ2V0IHNvcnRPcmRlcigpOiBDbHJEYXRhZ3JpZFNvcnRPcmRlcjtcbiAgICBzZXQgc29ydE9yZGVyKHZhbHVlOiBDbHJEYXRhZ3JpZFNvcnRPcmRlcik7XG4gICAgZ2V0IGFyaWFTb3J0KCk6IFwibm9uZVwiIHwgXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiO1xuICAgIHNvcnRPcmRlckNoYW5nZTogRXZlbnRFbWl0dGVyPENsckRhdGFncmlkU29ydE9yZGVyPjtcbiAgICBzb3J0SWNvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBkYXRhZ3JpZCBiYXNlZCBvbiB0aGlzIGNvbHVtblxuICAgICAqL1xuICAgIHNvcnQocmV2ZXJzZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIGZpbHRlciBmb3IgdGhpcyBjb2x1bW4gdGhhdCBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIHByb2plY3RlZCBjb250ZW50XG4gICAgICovXG4gICAgY3VzdG9tRmlsdGVyOiBib29sZWFuO1xuICAgIHNldCBwcm9qZWN0ZWRGaWx0ZXIoY3VzdG9tOiBhbnkpO1xuICAgIHByaXZhdGUgaW5pdEZpbHRlclZhbHVlO1xuICAgIGdldCBmaWx0ZXJWYWx1ZSgpOiBzdHJpbmcgfCBbbnVtYmVyLCBudW1iZXJdO1xuICAgIHNldCB1cGRhdGVGaWx0ZXJWYWx1ZShuZXdWYWx1ZTogc3RyaW5nIHwgW251bWJlciwgbnVtYmVyXSk7XG4gICAgc2V0IGZpbHRlclZhbHVlKG5ld1ZhbHVlOiBzdHJpbmcgfCBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICBmaWx0ZXJWYWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgcHJpdmF0ZSB3cmFwcGVkSW5qZWN0b3I7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBnZXQgX3ZpZXcoKTogYW55O1xufVxuIl19