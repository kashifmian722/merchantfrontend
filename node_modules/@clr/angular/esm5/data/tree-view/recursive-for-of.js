/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { ChangeDetectorRef, Directive, Input, OnChanges, OnDestroy, TemplateRef } from '@angular/core';
import { TreeFeaturesService } from './tree-features.service';
import { RecursiveTreeNodeModel } from './models/recursive-tree-node.model';
import { debounceTime } from 'rxjs/operators';
var ClrRecursiveForOf = /** @class */ (function () {
    function ClrRecursiveForOf(template, featuresService, cdr) {
        this.template = template;
        this.featuresService = featuresService;
        this.cdr = cdr;
    }
    // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
    ClrRecursiveForOf.prototype.ngOnChanges = function () {
        var _this = this;
        var wrapped;
        if (Array.isArray(this.nodes)) {
            wrapped = this.nodes.map(function (node) { return new RecursiveTreeNodeModel(node, null, _this.getChildren, _this.featuresService); });
        }
        else {
            wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren, this.featuresService)];
        }
        if (!this.childrenFetchSubscription) {
            this.childrenFetchSubscription = this.featuresService.childrenFetched.pipe(debounceTime(0)).subscribe(function () {
                _this.cdr.detectChanges();
            });
        }
        this.featuresService.recursion = {
            template: this.template,
            root: wrapped,
        };
    };
    ClrRecursiveForOf.prototype.ngOnDestroy = function () {
        if (this.childrenFetchSubscription) {
            this.childrenFetchSubscription.unsubscribe();
        }
    };
    ClrRecursiveForOf.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: TreeFeaturesService },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        Input('clrRecursiveForOf')
    ], ClrRecursiveForOf.prototype, "nodes", void 0);
    __decorate([
        Input('clrRecursiveForGetChildren')
    ], ClrRecursiveForOf.prototype, "getChildren", void 0);
    ClrRecursiveForOf = __decorate([
        Directive({ selector: '[clrRecursiveFor][clrRecursiveForOf]' })
    ], ClrRecursiveForOf);
    return ClrRecursiveForOf;
}());
export { ClrRecursiveForOf };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlLWZvci1vZi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjbHIvYW5ndWxhci8iLCJzb3VyY2VzIjpbImRhdGEvdHJlZS12aWV3L3JlY3Vyc2l2ZS1mb3Itb2YudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRzs7QUFFSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN2RyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUk1RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFROUM7SUFDRSwyQkFDVSxRQUFrRCxFQUNsRCxlQUF1QyxFQUN2QyxHQUFzQjtRQUZ0QixhQUFRLEdBQVIsUUFBUSxDQUEwQztRQUNsRCxvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7UUFDdkMsUUFBRyxHQUFILEdBQUcsQ0FBbUI7SUFDN0IsQ0FBQztJQVVKLCtHQUErRztJQUMvRyx1Q0FBVyxHQUFYO1FBQUEsaUJBaUJDO1FBaEJDLElBQUksT0FBb0MsQ0FBQztRQUN6QyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLElBQUksc0JBQXNCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFJLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxlQUFlLENBQUMsRUFBOUUsQ0FBOEUsQ0FBQyxDQUFDO1NBQ2xIO2FBQU07WUFDTCxPQUFPLEdBQUcsQ0FBQyxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7U0FDbEc7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUF5QixFQUFFO1lBQ25DLElBQUksQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUNwRyxLQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQzNCLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsR0FBRztZQUMvQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsSUFBSSxFQUFFLE9BQU87U0FDZCxDQUFDO0lBQ0osQ0FBQztJQUVELHVDQUFXLEdBQVg7UUFDRSxJQUFJLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtZQUNsQyxJQUFJLENBQUMseUJBQXlCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDOUM7SUFDSCxDQUFDOztnQkFyQ21CLFdBQVc7Z0JBQ0osbUJBQW1CO2dCQUMvQixpQkFBaUI7O0lBSUo7UUFBM0IsS0FBSyxDQUFDLG1CQUFtQixDQUFDO29EQUFnQjtJQUdOO1FBQXBDLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQzswREFBeUM7SUFYbEUsaUJBQWlCO1FBRDdCLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxzQ0FBc0MsRUFBRSxDQUFDO09BQ25ELGlCQUFpQixDQXdDN0I7SUFBRCx3QkFBQztDQUFBLEFBeENELElBd0NDO1NBeENZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy9yZWN1cnNpdmUtdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IFRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy90cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQXN5bmNBcnJheSB9IGZyb20gJy4vbW9kZWxzL2FzeW5jLWFycmF5JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPiB7XG4gICRpbXBsaWNpdDogVDtcbiAgY2xyTW9kZWw6IFRyZWVOb2RlTW9kZWw8VD47XG59XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJSZWN1cnNpdmVGb3JdW2NsclJlY3Vyc2l2ZUZvck9mXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJSZWN1cnNpdmVGb3JPZjxUPiBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8Q2xyUmVjdXJzaXZlRm9yT2ZDb250ZXh0PFQ+PixcbiAgICBwcml2YXRlIGZlYXR1cmVzU2VydmljZTogVHJlZUZlYXR1cmVzU2VydmljZTxUPixcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7fVxuXG4gIC8vIFRPRE86IGFjY2VwdCBOZ0l0ZXJhYmxlPFQ+XG4gIEBJbnB1dCgnY2xyUmVjdXJzaXZlRm9yT2YnKSBub2RlczogVCB8IFRbXTtcblxuICAvLyBUT0RPOiBhY2NlcHQgTmdJdGVyYWJsZTxUPiByZXR1cm4gdHlwZVxuICBASW5wdXQoJ2NsclJlY3Vyc2l2ZUZvckdldENoaWxkcmVuJykgZ2V0Q2hpbGRyZW46IChub2RlOiBUKSA9PiBBc3luY0FycmF5PFQ+O1xuXG4gIHByaXZhdGUgY2hpbGRyZW5GZXRjaFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8vIEknbSB1c2luZyBPbkNoYW5nZXMgaW5zdGVhZCBvZiBPbkluaXQgdG8gZWFzaWx5IGtlZXAgdXAgdG8gZGF0ZSB3aXRoIGR5bmFtaWMgdHJlZXMuIE1heWJlIG9wdGltaXphYmxlIGxhdGVyLlxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBsZXQgd3JhcHBlZDogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubm9kZXMpKSB7XG4gICAgICB3cmFwcGVkID0gdGhpcy5ub2Rlcy5tYXAobm9kZSA9PiBuZXcgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbChub2RlLCBudWxsLCB0aGlzLmdldENoaWxkcmVuLCB0aGlzLmZlYXR1cmVzU2VydmljZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVkID0gW25ldyBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsKHRoaXMubm9kZXMsIG51bGwsIHRoaXMuZ2V0Q2hpbGRyZW4sIHRoaXMuZmVhdHVyZXNTZXJ2aWNlKV07XG4gICAgfVxuICAgIGlmICghdGhpcy5jaGlsZHJlbkZldGNoU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuRmV0Y2hTdWJzY3JpcHRpb24gPSB0aGlzLmZlYXR1cmVzU2VydmljZS5jaGlsZHJlbkZldGNoZWQucGlwZShkZWJvdW5jZVRpbWUoMCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbiA9IHtcbiAgICAgIHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICAgICAgcm9vdDogd3JhcHBlZCxcbiAgICB9O1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5GZXRjaFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jaGlsZHJlbkZldGNoU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iXX0=