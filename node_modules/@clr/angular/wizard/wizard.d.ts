import { AfterContentInit, DoCheck, ElementRef, EventEmitter, IterableDiffers, OnDestroy, QueryList } from '@angular/core';
import { ButtonHubService } from './providers/button-hub.service';
import { HeaderActionService } from './providers/header-actions.service';
import { PageCollectionService } from './providers/page-collection.service';
import { WizardNavigationService } from './providers/wizard-navigation.service';
import { ClrWizardHeaderAction } from './wizard-header-action';
import { ClrWizardPage } from './wizard-page';
import * as ɵngcc0 from '@angular/core';
export declare class ClrWizard implements OnDestroy, AfterContentInit, DoCheck {
    private platformId;
    navService: WizardNavigationService;
    pageCollection: PageCollectionService;
    buttonService: ButtonHubService;
    headerActionService: HeaderActionService;
    private elementRef;
    /**
     * Set the modal size of the wizard. Set using `[clrWizardSize]` input.
     */
    size: string;
    /**
     * Tells the modal part of the wizard whether it should have a close "X"
     * in the top right corner. Set using `[clrWizardClosable]` input.
     */
    closable: boolean;
    /**
     * Resets page completed states when navigating backwards.
     * Set using `[clrWizardForceForwardNavigation]` input.
     */
    set forceForward(value: boolean);
    private _forceForward;
    get forceForward(): boolean;
    _open: boolean;
    /**
     * Toggles open/close of the wizard component.
     * Set using the `[clrWizardOpen]` input.
     */
    set clrWizardOpen(open: boolean);
    /**
     * Prevents ClrWizard from moving to the next page or closing itself on finishing.
     * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
     * will require you to create your own calls to .next() and .finish() in your
     * host component to make the ClrWizard work as expected.
     */
    set stopNext(value: boolean);
    private _stopNext;
    get stopNext(): boolean;
    /**
     * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
     * Set using the `[clrWizardPreventDefaultCancel]` input.
     *
     * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
     * to make the ClrWizard work as expected. Useful for doing checks or prompts
     * before closing a ClrWizard.
     */
    set stopCancel(value: boolean);
    private _stopCancel;
    get stopCancel(): boolean;
    /**
     * Prevents ClrWizard from performing any form of navigation away from the current
     * page. Set using the `[clrWizardPreventNavigation]` input.
     * Note that stopNavigation is meant to freeze the wizard in place, typically
     * during a long validation or background action where you want the wizard to
     * display loading content but not allow the user to execute navigation in
     * the stepnav, close X, or the  back, finish, or next buttons.
     */
    set stopNavigation(value: boolean);
    private _stopNavigation;
    get stopNavigation(): boolean;
    /**
     * Prevents clicks on the links in the stepnav from working.
     * Set using `[clrWizardDisableStepnav]` input.
     * A more granular bypassing of navigation which can be useful when your
     * ClrWizard is in a state of completion and you don't want users to be
     * able to jump backwards and change things.
     */
    set disableStepnav(value: boolean);
    private _disableStepnav;
    get disableStepnav(): boolean;
    /**
     * Used to communicate to the underlying modal that animations are not
     * wanted. Primary use is for the display of static/inline wizards.
     * Set using `[clrWizardPreventModalAnimation]` input.
     */
    /** @deprecated since 3.0, input should be removed in 4.0 because is only related to inline wizards */
    _stopModalAnimations: boolean;
    get stopModalAnimations(): string;
    /**
     * Emits when the wizard is opened or closed.
     * Listen via `(clrWizardOpenChange)` event.
     */
    _openChanged: EventEmitter<boolean>;
    /**
     * Emits when the wizard is canceled. Listen via `(clrWizardOnCancel)` event.
     * Can be combined with the `[clrWizardPreventDefaultCancel]` input to create
     * wizard-level custom cancel routines.
     */
    onCancel: EventEmitter<any>;
    /**
     * Emits when the wizard is completed. Listen via `(clrWizardOnFinish)` event.
     * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
     * wizard-level custom completion routines.
     */
    wizardFinished: EventEmitter<any>;
    /**
     * Emits when the wizard is reset. Listen via `(clrWizardOnReset)` event.
     */
    onReset: EventEmitter<any>;
    /**
     * Emits when the current page has changed. Listen via `(clrWizardCurrentPageChanged)` event.
     * output. Useful for non-blocking validation.
     */
    currentPageChanged: EventEmitter<any>;
    /**
     * Emits when the wizard moves to the next page. Listen via `(clrWizardOnNext)` event.
     * Can be combined with the `[clrWizardPreventDefaultNext]` input to create
     * wizard-level custom navigation routines, which are useful for validation.
     */
    onMoveNext: EventEmitter<any>;
    /**
     * Emits when the wizard moves to the previous page. Can be useful for validation.
     * Listen via `(clrWizardOnPrevious)` event.
     */
    onMovePrevious: EventEmitter<any>;
    pages: QueryList<ClrWizardPage>;
    headerActions: QueryList<ClrWizardHeaderAction>;
    wizardTitle: ElementRef;
    get currentPage(): ClrWizardPage;
    set currentPage(page: ClrWizardPage);
    get isLast(): boolean;
    get isFirst(): boolean;
    get isStatic(): boolean;
    private differ;
    private subscriptions;
    constructor(platformId: Object, navService: WizardNavigationService, pageCollection: PageCollectionService, buttonService: ButtonHubService, headerActionService: HeaderActionService, elementRef: ElementRef, differs: IterableDiffers);
    ngAfterContentInit(): void;
    ngDoCheck(): void;
    ngOnDestroy(): void;
    /**
     * Marks Wizard as finished. By default it does not execute event
     * emissions or checks before completing and closing. This method is commonly
     * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
     *
     * If `skipChecksAndEmits` is true, the wizard will complete and close
     * regardless of the state of its current page. This is useful for alternative
     * navigation where event emissions have already been done and firing them again
     * may cause an event loop.
     */
    finish(skipChecksAndEmits?: boolean): void;
    /**
     * Marks the wizard as finished but does run checks and emissions.
     * Good for a last step in an alternate workflow. Does the same thing as
     * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
     */
    forceFinish(): void;
    /**
     * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
     */
    open(): void;
    /**
     * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
     */
    close(): void;
    /**
     * Used to open and close the wizard. By default the wizard will
     * close if invoked with no parameter. If parameter is true wizard will open
     * else if false will close.
     */
    toggle(open: boolean): void;
    /**
     * Moves the wizard to the previous page.
     */
    previous(): void;
    /**
     * By default, `next()` does not execute event emissions.
     * This method is commonly called as part of an alternative navigation
     * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
     * regardless of the state of its current page. This is useful for alternative
     * navigation where event emissions have already been done and firing them again
     * may cause an event loop.
     *
     * If `skipChecksAndEmits` is false, the wizard will execute default checks
     * and emit events as normal. This is useful for custom buttons or programmatic
     * workflows that are not executing the wizards default checks and emissions.
     * It is another way to navigate without having to rewrite the wizard’s default
     * functionality from scratch.
     */
    next(skipChecksAndEmits?: boolean): void;
    /**
     * Moves the wizard to the next page without the checks and emissions.
     * Good for a last step in an alternate workflow.
     * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
     */
    forceNext(): void;
    /**
     * Cancels and closes the wizard. Do not use this for an override of the cancel
     * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
     * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
     * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
     */
    cancel(): void;
    /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
     */
    modalCancel(): void;
    /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
     */
    checkAndCancel(): void;
    /**
     * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * The format of the expected ID parameter can be found in the return of the
     * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
     * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
     */
    goTo(pageId: string): void;
    /**
     * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
     * be the current page, resetting the wizard navigation.
     * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
     */
    reset(): void;
    private listenForNextPageChanges;
    private listenForPreviousPageChanges;
    private listenForCancelChanges;
    private listenForFinishedChanges;
    private listenForPageChanges;
    private updateNavOnPageChanges;
    private initializeButtons;
    private emitWizardFinished;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ClrWizard>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ClrWizard, "clr-wizard", never, {
    "size": "clrWizardSize";
    "closable": "clrWizardClosable";
    "_stopModalAnimations": "clrWizardPreventModalAnimation";
    "forceForward": "clrWizardForceForwardNavigation";
    "clrWizardOpen": "clrWizardOpen";
    "stopNext": "clrWizardPreventDefaultNext";
    "stopCancel": "clrWizardPreventDefaultCancel";
    "stopNavigation": "clrWizardPreventNavigation";
    "disableStepnav": "clrWizardDisableStepnav";
}, {
    "_openChanged": "clrWizardOpenChange";
    "onCancel": "clrWizardOnCancel";
    "wizardFinished": "clrWizardOnFinish";
    "onReset": "clrWizardOnReset";
    "currentPageChanged": "clrWizardCurrentPageChanged";
    "onMoveNext": "clrWizardOnNext";
    "onMovePrevious": "clrWizardOnPrevious";
}, ["pages", "headerActions"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l6YXJkLmQudHMiLCJzb3VyY2VzIjpbIndpemFyZC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSXRlcmFibGVEaWZmZXJzLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnV0dG9uSHViU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZSc7XG5pbXBvcnQgeyBIZWFkZXJBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGVhZGVyLWFjdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uIH0gZnJvbSAnLi93aXphcmQtaGVhZGVyLWFjdGlvbic7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi93aXphcmQtcGFnZSc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDbHJXaXphcmQgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudEluaXQsIERvQ2hlY2sge1xuICAgIHByaXZhdGUgcGxhdGZvcm1JZDtcbiAgICBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZTtcbiAgICBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIGJ1dHRvblNlcnZpY2U6IEJ1dHRvbkh1YlNlcnZpY2U7XG4gICAgaGVhZGVyQWN0aW9uU2VydmljZTogSGVhZGVyQWN0aW9uU2VydmljZTtcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtb2RhbCBzaXplIG9mIHRoZSB3aXphcmQuIFNldCB1c2luZyBgW2NscldpemFyZFNpemVdYCBpbnB1dC5cbiAgICAgKi9cbiAgICBzaXplOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIG1vZGFsIHBhcnQgb2YgdGhlIHdpemFyZCB3aGV0aGVyIGl0IHNob3VsZCBoYXZlIGEgY2xvc2UgXCJYXCJcbiAgICAgKiBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lci4gU2V0IHVzaW5nIGBbY2xyV2l6YXJkQ2xvc2FibGVdYCBpbnB1dC5cbiAgICAgKi9cbiAgICBjbG9zYWJsZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgcGFnZSBjb21wbGV0ZWQgc3RhdGVzIHdoZW4gbmF2aWdhdGluZyBiYWNrd2FyZHMuXG4gICAgICogU2V0IHVzaW5nIGBbY2xyV2l6YXJkRm9yY2VGb3J3YXJkTmF2aWdhdGlvbl1gIGlucHV0LlxuICAgICAqL1xuICAgIHNldCBmb3JjZUZvcndhcmQodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByaXZhdGUgX2ZvcmNlRm9yd2FyZDtcbiAgICBnZXQgZm9yY2VGb3J3YXJkKCk6IGJvb2xlYW47XG4gICAgX29wZW46IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBvcGVuL2Nsb3NlIG9mIHRoZSB3aXphcmQgY29tcG9uZW50LlxuICAgICAqIFNldCB1c2luZyB0aGUgYFtjbHJXaXphcmRPcGVuXWAgaW5wdXQuXG4gICAgICovXG4gICAgc2V0IGNscldpemFyZE9wZW4ob3BlbjogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgQ2xyV2l6YXJkIGZyb20gbW92aW5nIHRvIHRoZSBuZXh0IHBhZ2Ugb3IgY2xvc2luZyBpdHNlbGYgb24gZmluaXNoaW5nLlxuICAgICAqIFNldCB1c2luZyB0aGUgYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHRdYCBpbnB1dC4gTm90ZSB0aGF0IHVzaW5nIHN0b3BOZXh0XG4gICAgICogd2lsbCByZXF1aXJlIHlvdSB0byBjcmVhdGUgeW91ciBvd24gY2FsbHMgdG8gLm5leHQoKSBhbmQgLmZpbmlzaCgpIGluIHlvdXJcbiAgICAgKiBob3N0IGNvbXBvbmVudCB0byBtYWtlIHRoZSBDbHJXaXphcmQgd29yayBhcyBleHBlY3RlZC5cbiAgICAgKi9cbiAgICBzZXQgc3RvcE5leHQodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByaXZhdGUgX3N0b3BOZXh0O1xuICAgIGdldCBzdG9wTmV4dCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIGNsb3Npbmcgd2hlbiB0aGUgY2FuY2VsIGJ1dHRvbiBvciBjbG9zZSBcIlhcIiBpcyBjbGlja2VkLlxuICAgICAqIFNldCB1c2luZyB0aGUgYFtjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbF1gIGlucHV0LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHVzaW5nIHN0b3BDYW5jZWwgd2lsbCByZXF1aXJlIHlvdSB0byBjcmVhdGUgeW91ciBvd24gY2FsbHMgdG8gYGNsb3NlKClgIGluIHlvdXIgaG9zdCBjb21wb25lYG50XG4gICAgICogdG8gbWFrZSB0aGUgQ2xyV2l6YXJkIHdvcmsgYXMgZXhwZWN0ZWQuIFVzZWZ1bCBmb3IgZG9pbmcgY2hlY2tzIG9yIHByb21wdHNcbiAgICAgKiBiZWZvcmUgY2xvc2luZyBhIENscldpemFyZC5cbiAgICAgKi9cbiAgICBzZXQgc3RvcENhbmNlbCh2YWx1ZTogYm9vbGVhbik7XG4gICAgcHJpdmF0ZSBfc3RvcENhbmNlbDtcbiAgICBnZXQgc3RvcENhbmNlbCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIHBlcmZvcm1pbmcgYW55IGZvcm0gb2YgbmF2aWdhdGlvbiBhd2F5IGZyb20gdGhlIGN1cnJlbnRcbiAgICAgKiBwYWdlLiBTZXQgdXNpbmcgdGhlIGBbY2xyV2l6YXJkUHJldmVudE5hdmlnYXRpb25dYCBpbnB1dC5cbiAgICAgKiBOb3RlIHRoYXQgc3RvcE5hdmlnYXRpb24gaXMgbWVhbnQgdG8gZnJlZXplIHRoZSB3aXphcmQgaW4gcGxhY2UsIHR5cGljYWxseVxuICAgICAqIGR1cmluZyBhIGxvbmcgdmFsaWRhdGlvbiBvciBiYWNrZ3JvdW5kIGFjdGlvbiB3aGVyZSB5b3Ugd2FudCB0aGUgd2l6YXJkIHRvXG4gICAgICogZGlzcGxheSBsb2FkaW5nIGNvbnRlbnQgYnV0IG5vdCBhbGxvdyB0aGUgdXNlciB0byBleGVjdXRlIG5hdmlnYXRpb24gaW5cbiAgICAgKiB0aGUgc3RlcG5hdiwgY2xvc2UgWCwgb3IgdGhlICBiYWNrLCBmaW5pc2gsIG9yIG5leHQgYnV0dG9ucy5cbiAgICAgKi9cbiAgICBzZXQgc3RvcE5hdmlnYXRpb24odmFsdWU6IGJvb2xlYW4pO1xuICAgIHByaXZhdGUgX3N0b3BOYXZpZ2F0aW9uO1xuICAgIGdldCBzdG9wTmF2aWdhdGlvbigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIGNsaWNrcyBvbiB0aGUgbGlua3MgaW4gdGhlIHN0ZXBuYXYgZnJvbSB3b3JraW5nLlxuICAgICAqIFNldCB1c2luZyBgW2NscldpemFyZERpc2FibGVTdGVwbmF2XWAgaW5wdXQuXG4gICAgICogQSBtb3JlIGdyYW51bGFyIGJ5cGFzc2luZyBvZiBuYXZpZ2F0aW9uIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VyXG4gICAgICogQ2xyV2l6YXJkIGlzIGluIGEgc3RhdGUgb2YgY29tcGxldGlvbiBhbmQgeW91IGRvbid0IHdhbnQgdXNlcnMgdG8gYmVcbiAgICAgKiBhYmxlIHRvIGp1bXAgYmFja3dhcmRzIGFuZCBjaGFuZ2UgdGhpbmdzLlxuICAgICAqL1xuICAgIHNldCBkaXNhYmxlU3RlcG5hdih2YWx1ZTogYm9vbGVhbik7XG4gICAgcHJpdmF0ZSBfZGlzYWJsZVN0ZXBuYXY7XG4gICAgZ2V0IGRpc2FibGVTdGVwbmF2KCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb21tdW5pY2F0ZSB0byB0aGUgdW5kZXJseWluZyBtb2RhbCB0aGF0IGFuaW1hdGlvbnMgYXJlIG5vdFxuICAgICAqIHdhbnRlZC4gUHJpbWFyeSB1c2UgaXMgZm9yIHRoZSBkaXNwbGF5IG9mIHN0YXRpYy9pbmxpbmUgd2l6YXJkcy5cbiAgICAgKiBTZXQgdXNpbmcgYFtjbHJXaXphcmRQcmV2ZW50TW9kYWxBbmltYXRpb25dYCBpbnB1dC5cbiAgICAgKi9cbiAgICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgMy4wLCBpbnB1dCBzaG91bGQgYmUgcmVtb3ZlZCBpbiA0LjAgYmVjYXVzZSBpcyBvbmx5IHJlbGF0ZWQgdG8gaW5saW5lIHdpemFyZHMgKi9cbiAgICBfc3RvcE1vZGFsQW5pbWF0aW9uczogYm9vbGVhbjtcbiAgICBnZXQgc3RvcE1vZGFsQW5pbWF0aW9ucygpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICogTGlzdGVuIHZpYSBgKGNscldpemFyZE9wZW5DaGFuZ2UpYCBldmVudC5cbiAgICAgKi9cbiAgICBfb3BlbkNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgY2FuY2VsZWQuIExpc3RlbiB2aWEgYChjbHJXaXphcmRPbkNhbmNlbClgIGV2ZW50LlxuICAgICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgW2NscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsXWAgaW5wdXQgdG8gY3JlYXRlXG4gICAgICogd2l6YXJkLWxldmVsIGN1c3RvbSBjYW5jZWwgcm91dGluZXMuXG4gICAgICovXG4gICAgb25DYW5jZWw6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBjb21wbGV0ZWQuIExpc3RlbiB2aWEgYChjbHJXaXphcmRPbkZpbmlzaClgIGV2ZW50LlxuICAgICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgW2NscldpemFyZFByZXZlbnREZWZhdWx0TmV4dF1gIGlucHV0IHRvIGNyZWF0ZVxuICAgICAqIHdpemFyZC1sZXZlbCBjdXN0b20gY29tcGxldGlvbiByb3V0aW5lcy5cbiAgICAgKi9cbiAgICB3aXphcmRGaW5pc2hlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIHJlc2V0LiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25SZXNldClgIGV2ZW50LlxuICAgICAqL1xuICAgIG9uUmVzZXQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIGN1cnJlbnQgcGFnZSBoYXMgY2hhbmdlZC4gTGlzdGVuIHZpYSBgKGNscldpemFyZEN1cnJlbnRQYWdlQ2hhbmdlZClgIGV2ZW50LlxuICAgICAqIG91dHB1dC4gVXNlZnVsIGZvciBub24tYmxvY2tpbmcgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBjdXJyZW50UGFnZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBtb3ZlcyB0byB0aGUgbmV4dCBwYWdlLiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25OZXh0KWAgZXZlbnQuXG4gICAgICogQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0XWAgaW5wdXQgdG8gY3JlYXRlXG4gICAgICogd2l6YXJkLWxldmVsIGN1c3RvbSBuYXZpZ2F0aW9uIHJvdXRpbmVzLCB3aGljaCBhcmUgdXNlZnVsIGZvciB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIG9uTW92ZU5leHQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBtb3ZlcyB0byB0aGUgcHJldmlvdXMgcGFnZS4gQ2FuIGJlIHVzZWZ1bCBmb3IgdmFsaWRhdGlvbi5cbiAgICAgKiBMaXN0ZW4gdmlhIGAoY2xyV2l6YXJkT25QcmV2aW91cylgIGV2ZW50LlxuICAgICAqL1xuICAgIG9uTW92ZVByZXZpb3VzOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBwYWdlczogUXVlcnlMaXN0PENscldpemFyZFBhZ2U+O1xuICAgIGhlYWRlckFjdGlvbnM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRIZWFkZXJBY3Rpb24+O1xuICAgIHdpemFyZFRpdGxlOiBFbGVtZW50UmVmO1xuICAgIGdldCBjdXJyZW50UGFnZSgpOiBDbHJXaXphcmRQYWdlO1xuICAgIHNldCBjdXJyZW50UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKTtcbiAgICBnZXQgaXNMYXN0KCk6IGJvb2xlYW47XG4gICAgZ2V0IGlzRmlyc3QoKTogYm9vbGVhbjtcbiAgICBnZXQgaXNTdGF0aWMoKTogYm9vbGVhbjtcbiAgICBwcml2YXRlIGRpZmZlcjtcbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm1JZDogT2JqZWN0LCBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZSwgcGFnZUNvbGxlY3Rpb246IFBhZ2VDb2xsZWN0aW9uU2VydmljZSwgYnV0dG9uU2VydmljZTogQnV0dG9uSHViU2VydmljZSwgaGVhZGVyQWN0aW9uU2VydmljZTogSGVhZGVyQWN0aW9uU2VydmljZSwgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzKTtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ0RvQ2hlY2soKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1hcmtzIFdpemFyZCBhcyBmaW5pc2hlZC4gQnkgZGVmYXVsdCBpdCBkb2VzIG5vdCBleGVjdXRlIGV2ZW50XG4gICAgICogZW1pc3Npb25zIG9yIGNoZWNrcyBiZWZvcmUgY29tcGxldGluZyBhbmQgY2xvc2luZy4gVGhpcyBtZXRob2QgaXMgY29tbW9ubHlcbiAgICAgKiB1c2VkIGFzIHBhcnQgb2YgYW4gYWx0ZXJuYXRpdmUgbmF2aWdhdGlvbiB3aXRoIGBbY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0XWAuXG4gICAgICpcbiAgICAgKiBJZiBgc2tpcENoZWNrc0FuZEVtaXRzYCBpcyB0cnVlLCB0aGUgd2l6YXJkIHdpbGwgY29tcGxldGUgYW5kIGNsb3NlXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2YgaXRzIGN1cnJlbnQgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsdGVybmF0aXZlXG4gICAgICogbmF2aWdhdGlvbiB3aGVyZSBldmVudCBlbWlzc2lvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gZG9uZSBhbmQgZmlyaW5nIHRoZW0gYWdhaW5cbiAgICAgKiBtYXkgY2F1c2UgYW4gZXZlbnQgbG9vcC5cbiAgICAgKi9cbiAgICBmaW5pc2goc2tpcENoZWNrc0FuZEVtaXRzPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHdpemFyZCBhcyBmaW5pc2hlZCBidXQgZG9lcyBydW4gY2hlY2tzIGFuZCBlbWlzc2lvbnMuXG4gICAgICogR29vZCBmb3IgYSBsYXN0IHN0ZXAgaW4gYW4gYWx0ZXJuYXRlIHdvcmtmbG93LiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICogY2FsbGluZyBgQ2xyV2l6YXJkLmZpbmlzaCh0cnVlKWAgb3IgYENscldpemFyZC5maW5pc2goKWAgd2l0aG91dCBhIHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBmb3JjZUZpbmlzaCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB3aXphcmQuIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgcGFnZSBkZWZpbmVkLCBzZXRzIHRoZSBmaXJzdCBwYWdlIGluIHRoZSB3aXphcmQgdG8gYmUgY3VycmVudC5cbiAgICAgKi9cbiAgICBvcGVuKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB3aXphcmQuIENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIGBjYW5jZWwoKWAgdG8gaW1wbGVtZW50IGFsdGVybmF0aXZlIGNhbmNlbCBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIGNsb3NlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBvcGVuIGFuZCBjbG9zZSB0aGUgd2l6YXJkLiBCeSBkZWZhdWx0IHRoZSB3aXphcmQgd2lsbFxuICAgICAqIGNsb3NlIGlmIGludm9rZWQgd2l0aCBubyBwYXJhbWV0ZXIuIElmIHBhcmFtZXRlciBpcyB0cnVlIHdpemFyZCB3aWxsIG9wZW5cbiAgICAgKiBlbHNlIGlmIGZhbHNlIHdpbGwgY2xvc2UuXG4gICAgICovXG4gICAgdG9nZ2xlKG9wZW46IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSB3aXphcmQgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCBgbmV4dCgpYCBkb2VzIG5vdCBleGVjdXRlIGV2ZW50IGVtaXNzaW9ucy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb21tb25seSBjYWxsZWQgYXMgcGFydCBvZiBhbiBhbHRlcm5hdGl2ZSBuYXZpZ2F0aW9uXG4gICAgICogd2l0aCBgW2NscldpemFyZFByZXZlbnREZWZhdWx0TmV4dF1gLiBUaGUgd2l6YXJkIHdpbGwgbW92ZSB0byB0aGUgbmV4dCBwYWdlXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2YgaXRzIGN1cnJlbnQgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsdGVybmF0aXZlXG4gICAgICogbmF2aWdhdGlvbiB3aGVyZSBldmVudCBlbWlzc2lvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gZG9uZSBhbmQgZmlyaW5nIHRoZW0gYWdhaW5cbiAgICAgKiBtYXkgY2F1c2UgYW4gZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqIElmIGBza2lwQ2hlY2tzQW5kRW1pdHNgIGlzIGZhbHNlLCB0aGUgd2l6YXJkIHdpbGwgZXhlY3V0ZSBkZWZhdWx0IGNoZWNrc1xuICAgICAqIGFuZCBlbWl0IGV2ZW50cyBhcyBub3JtYWwuIFRoaXMgaXMgdXNlZnVsIGZvciBjdXN0b20gYnV0dG9ucyBvciBwcm9ncmFtbWF0aWNcbiAgICAgKiB3b3JrZmxvd3MgdGhhdCBhcmUgbm90IGV4ZWN1dGluZyB0aGUgd2l6YXJkcyBkZWZhdWx0IGNoZWNrcyBhbmQgZW1pc3Npb25zLlxuICAgICAqIEl0IGlzIGFub3RoZXIgd2F5IHRvIG5hdmlnYXRlIHdpdGhvdXQgaGF2aW5nIHRvIHJld3JpdGUgdGhlIHdpemFyZOKAmXMgZGVmYXVsdFxuICAgICAqIGZ1bmN0aW9uYWxpdHkgZnJvbSBzY3JhdGNoLlxuICAgICAqL1xuICAgIG5leHQoc2tpcENoZWNrc0FuZEVtaXRzPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHdpemFyZCB0byB0aGUgbmV4dCBwYWdlIHdpdGhvdXQgdGhlIGNoZWNrcyBhbmQgZW1pc3Npb25zLlxuICAgICAqIEdvb2QgZm9yIGEgbGFzdCBzdGVwIGluIGFuIGFsdGVybmF0ZSB3b3JrZmxvdy5cbiAgICAgKiBBbGlhcyBmb3IgYENscldpemFyZC5uZXh0KHRydWUpYCBvciBgQ2xyV2l6YXJkLm5leHQoKWBcbiAgICAgKi9cbiAgICBmb3JjZU5leHQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuZCBjbG9zZXMgdGhlIHdpemFyZC4gRG8gbm90IHVzZSB0aGlzIGZvciBhbiBvdmVycmlkZSBvZiB0aGUgY2FuY2VsXG4gICAgICogdGhlIGZ1bmN0aW9uYWxpdHkgd2l0aCBgW2NscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsXWAsIGBbY2xyV2l6YXJkUHJldmVudFBhZ2VEZWZhdWx0Q2FuY2VsXWAsXG4gICAgICogb3IgYFtjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHRdYCBiZWNhdXNlIGl0IHdpbGwgaW5pdGlhdGUgdGhlIHNhbWUgY2hlY2tzXG4gICAgICogYW5kIGV2ZW50IGVtaXNzaW9ucyB0aGF0IGludm9rZWQgeW91ciBldmVudCBoYW5kbGVyLiBVc2UgYENscldpemFyZC5jbG9zZSgpYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGNhbmNlbCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBiZWhhdmlvciBvZiB0aGUgdW5kZXJseWluZyBtb2RhbCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGhcbiAgICAgKiBhbHRlcm5hdGl2ZSBjYW5jZWwgZnVuY3Rpb25hbGl0eS4gSW4gbW9zdCBjYXNlcywgdXNlIGBDbHJXaXphcmQuY2FuY2VsKClgIGluc3RlYWQuXG4gICAgICovXG4gICAgbW9kYWxDYW5jZWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGFsdGVybmF0aXZlIGNhbmNlbCBmbG93cyBkZWZpbmVkIGF0IHRoZSBjdXJyZW50IHBhZ2Ugb3JcbiAgICAgKiB3aXphcmQgbGV2ZWwuIFBlcmZvcm1zIGEgY2FuY2VsZWQgaWYgbm90LiBFbWl0cyBldmVudHMgdGhhdCBpbml0aWF0ZVxuICAgICAqIHRoZSBhbHRlcm5hdGl2ZSBjYW5jZWwgb3V0cHV0cyBgKGNscldpemFyZFBhZ2VPbkNhbmNlbClgIGFuZCBgKGNscldpemFyZE9uQ2FuY2VsKWAuXG4gICAgICovXG4gICAgY2hlY2tBbmRDYW5jZWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gYSBnaXZlbiBwYWdlIGluIHRoZSBXaXphcmQuIE5hdmlnYXRpb24gd2lsbCBpbnZva2UgdGhlIHdpemFyZOKAmXMgZGVmYXVsdFxuICAgICAqIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zLlxuICAgICAqXG4gICAgICogVGhlIGZvcm1hdCBvZiB0aGUgZXhwZWN0ZWQgSUQgcGFyYW1ldGVyIGNhbiBiZSBmb3VuZCBpbiB0aGUgcmV0dXJuIG9mIHRoZVxuICAgICAqIENscldpemFyZFBhZ2UuaWQgZ2V0dGVyLCB1c3VhbGx5IHByZWZpeGVkIHdpdGggYGNsci13aXphcmQtcGFnZS1gIGFuZCB0aGVuIGVpdGhlciBhXG4gICAgICogbnVtZXJpYyBJRCBvciB0aGUgSUQgc3BlY2lmaWVkIGZvciB0aGUgYENscldpemFyZFBhZ2VgIGNvbXBvbmVudOKAmXMgYGlkYCBpbnB1dC5cbiAgICAgKi9cbiAgICBnb1RvKHBhZ2VJZDogc3RyaW5nKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXNldCBzZXRzIGFsbCBXaXphcmRQYWdlcyB0byBpbmNvbXBsZXRlIGFuZCBzZXRzIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBgQ2xyV2l6YXJkYCB0b1xuICAgICAqIGJlIHRoZSBjdXJyZW50IHBhZ2UsIHJlc2V0dGluZyB0aGUgd2l6YXJkIG5hdmlnYXRpb24uXG4gICAgICogVXNlIGAoY2xyV2l6YXJkT25SZXNldClgIGV2ZW50IHRvIHJlc2V0IHRoZSBkYXRhIG9yIG1vZGVsIG9mIHlvdXIgd2l6YXJkLlxuICAgICAqL1xuICAgIHJlc2V0KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBsaXN0ZW5Gb3JOZXh0UGFnZUNoYW5nZXM7XG4gICAgcHJpdmF0ZSBsaXN0ZW5Gb3JQcmV2aW91c1BhZ2VDaGFuZ2VzO1xuICAgIHByaXZhdGUgbGlzdGVuRm9yQ2FuY2VsQ2hhbmdlcztcbiAgICBwcml2YXRlIGxpc3RlbkZvckZpbmlzaGVkQ2hhbmdlcztcbiAgICBwcml2YXRlIGxpc3RlbkZvclBhZ2VDaGFuZ2VzO1xuICAgIHByaXZhdGUgdXBkYXRlTmF2T25QYWdlQ2hhbmdlcztcbiAgICBwcml2YXRlIGluaXRpYWxpemVCdXR0b25zO1xuICAgIHByaXZhdGUgZW1pdFdpemFyZEZpbmlzaGVkO1xufVxuIl19