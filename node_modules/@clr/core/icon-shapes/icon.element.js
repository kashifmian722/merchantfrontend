/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __metadata } from "tslib";
import { applyMixins, baseStyles, CssHelpers, hasStringPropertyChanged, hasStringPropertyChangedAndNotNil, property, UniqueId, } from '@clr/core/common';
import { html, LitElement, query } from 'lit-element';
import { unsafeHTML } from 'lit-html/directives/unsafe-html';
import { styles } from './icon.element.css';
import { ClarityIcons } from './icon.service';
import { updateIconSizeStyleOrClassnames } from './utils/icon.classnames';
import { hasIcon } from './utils/icon.service-helpers';
class IconMixinClass extends LitElement {
}
applyMixins(IconMixinClass, [UniqueId, CssHelpers]);
/**
 * Icon component that renders svg shapes that can be customized.
 * To load a icon import the need icon with the icon service.
 *
 * ```typescript
 * import '@clr/core/icon';
 * import { ClarityIcons, userIcon } from '@clr/core/icon-shapes';
 *
 * ClarityIcons.addIcons(userIcon);
 * ```
 *
 * ```html
 * <cds-icon shape="user"></cds-icon>
 * ```
 *
 * @element cds-icon
 * @cssprop --clr-icon-color
 * @cssprop --clr-icon-color-success
 * @cssprop --clr-icon-color-danger
 * @cssprop --clr-icon-color-warning
 * @cssprop --clr-icon-color-info
 * @cssprop --clr-icon-color-inverse
 * @cssprop --clr-icon-color-inverse-success
 * @cssprop --clr-icon-color-inverse-danger
 * @cssprop --clr-icon-color-inverse-warning
 * @cssprop --clr-icon-color-inverse-info
 */
// @dynamic
export class CdsIcon extends IconMixinClass {
    constructor() {
        super(...arguments);
        /**
         * Displays most icons in their "filled" version if set to `true`.
         */
        this.solid = false;
        /**
         * Changes color of icon fills and outlines to a color determined by the following
         * list of statuses: 'info', 'success', 'warning', 'danger', 'highlight'
         */
        this.status = '';
        /**
         * Inverts color of icon fills and outlines if `true`.
         * Useful for displaying icons on a dark background.
         */
        this.inverse = false;
        this.ariaLabel = `aria-${this._idPrefix}${this._uniqueId}`;
    }
    static get styles() {
        return [baseStyles, styles];
    }
    get shape() {
        return hasIcon(this._shape, ClarityIcons.registry) ? this._shape : 'unknown';
    }
    /**
     * Changes the svg glyph displayed in the icon component. Defaults to the 'unknown' icon if
     * the specified icon cannot be found in the icon registry.
     */
    set shape(val) {
        if (hasStringPropertyChangedAndNotNil(val, this._shape)) {
            const oldVal = this._shape;
            this._shape = val;
            this.requestUpdate('shape', oldVal);
        }
    }
    get size() {
        return this._size;
    }
    /** Apply numerical width-height or a t-shirt-sized CSS classname */
    set size(val) {
        if (hasStringPropertyChanged(val, this._size)) {
            const oldVal = this._size;
            this._size = val;
            updateIconSizeStyleOrClassnames(this, val);
            this.requestUpdate('size', oldVal);
        }
    }
    firstUpdated() {
        this.updateSVGAriaLabel();
    }
    updated(props) {
        if (props.has('title')) {
            this.updateSVGAriaLabel();
        }
    }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute('role', 'none');
    }
    render() {
        return html `
      ${unsafeHTML(ClarityIcons.registry[this.shape])}
      ${this.title ? html `<span id="${this.ariaLabel}" class="clr-sr-only">${this.title}</span>` : ''}
    `;
    }
    updateSVGAriaLabel() {
        if (this.title) {
            this.svg.removeAttribute('aria-label'); // remove empty label that makes icon decorative by default
            this.svg.setAttribute('aria-labelledby', this.ariaLabel); // use labelledby for better SR support
        }
        else {
            this.svg.removeAttribute('aria-labelledby');
        }
    }
}
__decorate([
    property({ type: String }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], CdsIcon.prototype, "shape", null);
__decorate([
    property({ type: String }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], CdsIcon.prototype, "size", null);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], CdsIcon.prototype, "title", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], CdsIcon.prototype, "dir", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], CdsIcon.prototype, "direction", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], CdsIcon.prototype, "flip", void 0);
__decorate([
    property({ type: Boolean }),
    __metadata("design:type", Object)
], CdsIcon.prototype, "solid", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], CdsIcon.prototype, "status", void 0);
__decorate([
    property({ type: Boolean }),
    __metadata("design:type", Object)
], CdsIcon.prototype, "inverse", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", Object)
], CdsIcon.prototype, "badge", void 0);
__decorate([
    query('svg'),
    __metadata("design:type", SVGElement)
], CdsIcon.prototype, "svg", void 0);
//# sourceMappingURL=icon.element.js.map