import { __decorate } from "tslib";
/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from '@angular/core';
import { ALL_COLUMN_CHANGES } from '../enums/column-changes.enum';
let ColumnsService = class ColumnsService {
    constructor() {
        this.columns = [];
        this._cache = [];
    }
    cache() {
        this._cache = this.columns.map(subject => {
            const value = Object.assign({}, subject.value);
            delete value.changes;
            return value;
        });
    }
    hasCache() {
        return !!this._cache.length;
    }
    resetToLastCache() {
        this._cache.forEach((state, index) => {
            // Just emit the exact value from the cache
            this.columns[index].next(Object.assign(Object.assign({}, state), { changes: ALL_COLUMN_CHANGES }));
        });
        this._cache = [];
    }
    get columnStates() {
        return this.columns.map(column => column.value);
    }
    get hasHideableColumns() {
        return this.columnStates.filter(state => state.hideable).length > 0;
    }
    // Helper method to emit a change to a column only when there is an actual diff to process for that column
    emitStateChangeAt(columnIndex, diff) {
        if (!this.columns[columnIndex]) {
            return;
        }
        this.emitStateChange(this.columns[columnIndex], diff);
    }
    emitStateChange(column, diff) {
        column.next(Object.assign(Object.assign({}, column.value), diff));
    }
};
ColumnsService = __decorate([
    Injectable()
], ColumnsService);
export { ColumnsService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1ucy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNsci9hbmd1bGFyLyIsInNvdXJjZXMiOlsiZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvY29sdW1ucy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHO0FBQ0gsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUdsRSxJQUFhLGNBQWMsR0FBM0IsTUFBYSxjQUFjO0lBQTNCO1FBQ0UsWUFBTyxHQUFtQyxFQUFFLENBQUM7UUFDckMsV0FBTSxHQUFrQixFQUFFLENBQUM7SUF5Q3JDLENBQUM7SUF2Q0MsS0FBSztRQUNILElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdkMsTUFBTSxLQUFLLHFCQUFRLE9BQU8sQ0FBQyxLQUFLLENBQUUsQ0FBQztZQUNuQyxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUM7WUFDckIsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDOUIsQ0FBQztJQUVELGdCQUFnQjtRQUNkLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ25DLDJDQUEyQztZQUMzQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksaUNBQU0sS0FBSyxLQUFFLE9BQU8sRUFBRSxrQkFBa0IsSUFBRyxDQUFDO1FBQ3RFLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELElBQUksWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVELElBQUksa0JBQWtCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRUQsMEdBQTBHO0lBQzFHLGlCQUFpQixDQUFDLFdBQW1CLEVBQUUsSUFBcUI7UUFDMUQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDOUIsT0FBTztTQUNSO1FBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxlQUFlLENBQUMsTUFBb0MsRUFBRSxJQUFxQjtRQUN6RSxNQUFNLENBQUMsSUFBSSxpQ0FBTSxNQUFNLENBQUMsS0FBSyxHQUFLLElBQUksRUFBRyxDQUFDO0lBQzVDLENBQUM7Q0FDRixDQUFBO0FBM0NZLGNBQWM7SUFEMUIsVUFBVSxFQUFFO0dBQ0EsY0FBYyxDQTJDMUI7U0EzQ1ksY0FBYyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ29sdW1uU3RhdGVEaWZmLCBDb2x1bW5TdGF0ZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29sdW1uLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBBTExfQ09MVU1OX0NIQU5HRVMgfSBmcm9tICcuLi9lbnVtcy9jb2x1bW4tY2hhbmdlcy5lbnVtJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbHVtbnNTZXJ2aWNlIHtcbiAgY29sdW1uczogQmVoYXZpb3JTdWJqZWN0PENvbHVtblN0YXRlPltdID0gW107XG4gIHByaXZhdGUgX2NhY2hlOiBDb2x1bW5TdGF0ZVtdID0gW107XG5cbiAgY2FjaGUoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB0aGlzLmNvbHVtbnMubWFwKHN1YmplY3QgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB7IC4uLnN1YmplY3QudmFsdWUgfTtcbiAgICAgIGRlbGV0ZSB2YWx1ZS5jaGFuZ2VzO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgaGFzQ2FjaGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fY2FjaGUubGVuZ3RoO1xuICB9XG5cbiAgcmVzZXRUb0xhc3RDYWNoZSgpIHtcbiAgICB0aGlzLl9jYWNoZS5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIEp1c3QgZW1pdCB0aGUgZXhhY3QgdmFsdWUgZnJvbSB0aGUgY2FjaGVcbiAgICAgIHRoaXMuY29sdW1uc1tpbmRleF0ubmV4dCh7IC4uLnN0YXRlLCBjaGFuZ2VzOiBBTExfQ09MVU1OX0NIQU5HRVMgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fY2FjaGUgPSBbXTtcbiAgfVxuXG4gIGdldCBjb2x1bW5TdGF0ZXMoKTogQ29sdW1uU3RhdGVbXSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1ucy5tYXAoY29sdW1uID0+IGNvbHVtbi52YWx1ZSk7XG4gIH1cblxuICBnZXQgaGFzSGlkZWFibGVDb2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbHVtblN0YXRlcy5maWx0ZXIoc3RhdGUgPT4gc3RhdGUuaGlkZWFibGUpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kIHRvIGVtaXQgYSBjaGFuZ2UgdG8gYSBjb2x1bW4gb25seSB3aGVuIHRoZXJlIGlzIGFuIGFjdHVhbCBkaWZmIHRvIHByb2Nlc3MgZm9yIHRoYXQgY29sdW1uXG4gIGVtaXRTdGF0ZUNoYW5nZUF0KGNvbHVtbkluZGV4OiBudW1iZXIsIGRpZmY6IENvbHVtblN0YXRlRGlmZikge1xuICAgIGlmICghdGhpcy5jb2x1bW5zW2NvbHVtbkluZGV4XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXRTdGF0ZUNoYW5nZSh0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdLCBkaWZmKTtcbiAgfVxuXG4gIGVtaXRTdGF0ZUNoYW5nZShjb2x1bW46IEJlaGF2aW9yU3ViamVjdDxDb2x1bW5TdGF0ZT4sIGRpZmY6IENvbHVtblN0YXRlRGlmZikge1xuICAgIGNvbHVtbi5uZXh0KHsgLi4uY29sdW1uLnZhbHVlLCAuLi5kaWZmIH0pO1xuICB9XG59XG4iXX0=