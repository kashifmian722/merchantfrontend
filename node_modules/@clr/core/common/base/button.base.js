/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __metadata } from "tslib";
import { html, LitElement, query } from 'lit-element';
import { ifDefined } from 'lit-html/directives/if-defined';
import { property } from '../decorators/property';
import { querySlot } from '../decorators/query-slot';
import { KeyCodes } from './../enums/key-codes';
import { stopEvent } from './../utils/events';
// @dynamic
export class CdsBaseButton extends LitElement {
    constructor() {
        super(...arguments);
        this.readonly = false;
        this.role = 'button';
        this.name = '';
        this.value = '';
        this.disabled = false;
    }
    get hiddenButtonTemplate() {
        return this.readonly
            ? html ``
            : html `
      <button
          aria-hidden="true"
          ?disabled="${this.disabled}"
          tabindex="-1"
          style="display: none"
          value="${ifDefined(this.value)}"
          name="${ifDefined(name)}"
          type="${ifDefined(this.type)}"
        ></button>`;
    }
    render() {
        return html `
      <slot></slot>
      ${this.hiddenButtonTemplate}
    `;
    }
    firstUpdated(props) {
        super.firstUpdated(props);
        this.updateButtonAttributes();
        this.setupNativeButtonBehavior();
    }
    updated(props) {
        super.updated(props);
        // if readonly or disabled attribute was updated, button attributes might need updating
        if (props.has('readonly') || props.has('disabled')) {
            this.updateButtonAttributes();
        }
    }
    /**
     * We have to append a hidden button outside the web component in the light DOM
     * This allows us to trigger native submit events within a form element.
     */
    setupNativeButtonBehavior() {
        this.appendHiddenButton();
        this.addEventListener('click', e => this.triggerNativeButtonBehavior(e));
        this.addEventListener('keydown', e => this.emulateKeyBoardEventBehavior(e));
    }
    triggerNativeButtonBehavior(event) {
        if (!this.readonly) {
            if (this.disabled) {
                stopEvent(event);
            }
            else if (event.target === this && !event.defaultPrevented) {
                this.hiddenButton.dispatchEvent(new MouseEvent('click', { relatedTarget: this, composed: true }));
            }
        }
    }
    appendHiddenButton() {
        if (!this.hiddenButton && this.templateButton) {
            this.hiddenButton = this.appendChild(this.templateButton);
        }
    }
    emulateKeyBoardEventBehavior(e) {
        if (!this.anchor && (e.key === KeyCodes.Enter || e.code === KeyCodes.Space)) {
            this.click();
            stopEvent(e);
        }
    }
    updateButtonAttributes() {
        const oldRole = this.role;
        const oldTabIndex = this.tabIndex;
        if (this.anchor) {
            this.readonly = true;
            this.setAttribute('is-anchor', '');
        }
        if (this.readonly) {
            this.removeAttribute('role');
            this.removeAttribute('tabIndex');
            this.appendHiddenButton();
        }
        else {
            this.role = 'button';
            this.tabIndex = this.disabled ? -1 : 0;
        }
        if (this.role !== oldRole) {
            this.requestUpdate('role', oldRole);
        }
        if (this.tabIndex !== oldTabIndex) {
            this.requestUpdate('tabIndex', oldTabIndex);
        }
    }
}
__decorate([
    property({ type: Boolean }),
    __metadata("design:type", Object)
], CdsBaseButton.prototype, "readonly", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", Object)
], CdsBaseButton.prototype, "role", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], CdsBaseButton.prototype, "type", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", Object)
], CdsBaseButton.prototype, "name", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", Object)
], CdsBaseButton.prototype, "value", void 0);
__decorate([
    property({ type: Boolean }),
    __metadata("design:type", Object)
], CdsBaseButton.prototype, "disabled", void 0);
__decorate([
    querySlot('a'),
    __metadata("design:type", HTMLAnchorElement)
], CdsBaseButton.prototype, "anchor", void 0);
__decorate([
    query('button'),
    __metadata("design:type", HTMLButtonElement)
], CdsBaseButton.prototype, "templateButton", void 0);
//# sourceMappingURL=button.base.js.map