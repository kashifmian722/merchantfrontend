/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { animate, style, transition, trigger, state } from '@angular/animations';
import { isPlatformBrowser } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, Inject, Injector, Input, OnDestroy, OnInit, Optional, Output, PLATFORM_ID, QueryList, SkipSelf, ViewChild, } from '@angular/core';
import { filter } from 'rxjs/operators';
import { KeyCodes } from './../../utils/enums/key-codes.enum';
import { IfExpandService } from '../../utils/conditional/if-expanded.service';
import { keyValidator, preventArrowKeyScroll } from '../../utils/focus/key-focus/util';
import { ClrCommonStringsService } from '../../utils/i18n/common-strings.service';
import { UNIQUE_ID, UNIQUE_ID_PROVIDER } from '../../utils/id-generator/id-generator.service';
import { LoadingListener } from '../../utils/loading/loading-listener';
import { DeclarativeTreeNodeModel } from './models/declarative-tree-node.model';
import { ClrSelectedState } from './models/selected-state.enum';
import { TreeFeaturesService, TREE_FEATURES_PROVIDER } from './tree-features.service';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { ClrTreeNodeLink } from './tree-node-link';
var LVIEW_CONTEXT_INDEX = 8;
var ClrTreeNode = /** @class */ (function () {
    function ClrTreeNode(nodeId, platformId, parent, featuresService, expandService, commonStrings, focusManager, injector) {
        this.nodeId = nodeId;
        this.platformId = platformId;
        this.featuresService = featuresService;
        this.expandService = expandService;
        this.commonStrings = commonStrings;
        this.focusManager = focusManager;
        this.STATES = ClrSelectedState;
        this.skipEmitChange = false;
        this.selectedChange = new EventEmitter(false);
        this.expandedChange = new EventEmitter();
        this.subscriptions = [];
        this.contentContainerTabindex = -1;
        if (this.featuresService.recursion) {
            // I'm completely stuck, we have to hack into private properties until either
            // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
            // are fixed
            // This is for non-ivy implementations
            if (injector.view) {
                this._model = injector.view.context.clrModel;
            }
            else {
                // Ivy puts this on a specific index of a _lView property
                // tslint:disable-next-line
                this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
            }
        }
        else {
            // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
            this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
        }
        this._model.nodeId = this.nodeId;
    }
    ClrTreeNode.prototype.isExpandable = function () {
        if (typeof this.expandable !== 'undefined') {
            return this.expandable;
        }
        return !!this.expandService.expandable || (this._model.children && this._model.children.length > 0);
    };
    Object.defineProperty(ClrTreeNode.prototype, "selected", {
        get: function () {
            return this._model.selected.value;
        },
        set: function (value) {
            this.featuresService.selectable = true;
            // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
            // This shouldn't happen with strict typing on the app's side, but it's not up to us.
            if (value === null || typeof value === 'undefined') {
                value = ClrSelectedState.UNSELECTED;
            }
            // We match booleans to the corresponding ClrSelectedState
            if (typeof value === 'boolean') {
                value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
            }
            // We propagate only if the tree is in smart mode, and skip emitting the output when we set the input
            // See https://github.com/vmware/clarity/issues/3073
            this.skipEmitChange = true;
            this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
            this.skipEmitChange = false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTreeNode.prototype, "ariaSelected", {
        get: function () {
            return this.featuresService.selectable ? this._model.selected.value === ClrSelectedState.SELECTED : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTreeNode.prototype, "expanded", {
        // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
        // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
        // case, you can't use a structural directive, it would need to go on an ng-container.
        get: function () {
            return this.expandService.expanded;
        },
        set: function (value) {
            this.expandService.expanded = value;
        },
        enumerable: true,
        configurable: true
    });
    ClrTreeNode.prototype.ngOnInit = function () {
        var _this = this;
        this._model.expanded = this.expanded;
        this.subscriptions.push(this._model.selected.pipe(filter(function () { return !_this.skipEmitChange; })).subscribe(function (value) {
            _this.selectedChange.emit(value);
        }));
        this.subscriptions.push(this.expandService.expandChange.subscribe(function (value) {
            _this.expandedChange.emit(value);
            _this._model.expanded = value;
        }));
        this.subscriptions.push(this.focusManager.focusRequest.subscribe(function (nodeId) {
            if (_this.nodeId === nodeId) {
                _this.focusTreeNode();
            }
        }), this.focusManager.focusChange.subscribe(function (nodeId) {
            _this.checkTabIndex(nodeId);
        }));
    };
    ClrTreeNode.prototype.ngOnDestroy = function () {
        this._model.destroy();
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    Object.defineProperty(ClrTreeNode.prototype, "treeNodeLink", {
        get: function () {
            return this.treeNodeLinkList && this.treeNodeLinkList.first;
        },
        enumerable: true,
        configurable: true
    });
    ClrTreeNode.prototype.setTabIndex = function (value) {
        this.contentContainerTabindex = value;
        this.contentContainer.nativeElement.setAttribute('tabindex', value);
    };
    ClrTreeNode.prototype.checkTabIndex = function (nodeId) {
        if (isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
            this.setTabIndex(-1);
        }
    };
    ClrTreeNode.prototype.focusTreeNode = function () {
        if (isPlatformBrowser(this.platformId) && document.activeElement !== this.contentContainer.nativeElement) {
            this.setTabIndex(0);
            this.contentContainer.nativeElement.focus();
        }
    };
    ClrTreeNode.prototype.broadcastFocusOnContainer = function () {
        this.focusManager.broadcastFocusedNode(this.nodeId);
    };
    ClrTreeNode.prototype.onKeyDown = function (event) {
        // Two reasons to prevent default behavior:
        // 1. to prevent scrolling on arrow keys
        // 2. Assistive Technology focus differs from Keyboard focus behavior.
        //    By default, pressing arrow key makes AT focus go into the nested content of the item.
        preventArrowKeyScroll(event);
        // https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-22
        switch (keyValidator(event.key)) {
            case KeyCodes.ArrowUp:
                this.focusManager.focusNodeAbove(this._model);
                break;
            case KeyCodes.ArrowDown:
                this.focusManager.focusNodeBelow(this._model);
                break;
            case KeyCodes.ArrowRight:
                this.expandOrFocusFirstChild();
                break;
            case KeyCodes.ArrowLeft:
                this.collapseOrFocusParent();
                break;
            case KeyCodes.Home:
                this.focusManager.focusFirstVisibleNode();
                break;
            case KeyCodes.End:
                this.focusManager.focusLastVisibleNode();
                break;
            case KeyCodes.Enter:
                this.triggerDefaultAction();
                break;
            case KeyCodes.Space:
                // to prevent scrolling on space key in this specific case
                event.preventDefault();
                this.triggerDefaultAction();
                break;
            default:
                break;
        }
    };
    ClrTreeNode.prototype.expandOrFocusFirstChild = function () {
        if (this.expanded) {
            // if the node is already expanded and has children, focus its very first child
            if (this._model.children.length > 0) {
                this.focusManager.focusNodeBelow(this._model);
            }
        }
        else {
            // we must check if the node is expandable, in order to set .expanded to true from false
            // because we shouldn't set .expanded to true if it's not expandable node
            if (this.isExpandable()) {
                this.expandService.expanded = true;
            }
        }
    };
    ClrTreeNode.prototype.collapseOrFocusParent = function () {
        if (this.expanded) {
            this.expandService.expanded = false;
        }
        else {
            this.focusManager.focusParent(this._model);
        }
    };
    ClrTreeNode.prototype.triggerDefaultAction = function () {
        if (this.treeNodeLink) {
            this.treeNodeLink.activate();
        }
        else {
            if (this.featuresService.selectable) {
                this._model.toggleSelection(this.featuresService.eager);
            }
        }
    };
    ClrTreeNode.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: ClrTreeNode, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: TreeFeaturesService },
        { type: IfExpandService },
        { type: ClrCommonStringsService },
        { type: TreeFocusManagerService },
        { type: Injector }
    ]; };
    __decorate([
        Input('clrSelected')
    ], ClrTreeNode.prototype, "selected", null);
    __decorate([
        Output('clrSelectedChange')
    ], ClrTreeNode.prototype, "selectedChange", void 0);
    __decorate([
        Input('clrExpandable')
    ], ClrTreeNode.prototype, "expandable", void 0);
    __decorate([
        Input('clrExpanded')
    ], ClrTreeNode.prototype, "expanded", null);
    __decorate([
        Output('clrExpandedChange')
    ], ClrTreeNode.prototype, "expandedChange", void 0);
    __decorate([
        ViewChild('contentContainer', { read: ElementRef, static: true })
    ], ClrTreeNode.prototype, "contentContainer", void 0);
    __decorate([
        ContentChildren(ClrTreeNodeLink, { descendants: false })
    ], ClrTreeNode.prototype, "treeNodeLinkList", void 0);
    ClrTreeNode = __decorate([
        Component({
            selector: 'clr-tree-node',
            template: "<!--\n  ~ Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div #contentContainer role=\"treeitem\" \n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\" \n  (keydown)=\"onKeyDown($event)\" \n  (focus)=\"broadcastFocusOnContainer()\">\n  <button\n    *ngIf=\"isExpandable() && !_model.loading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\" (focus)=\"focusTreeNode()\">\n    <clr-icon\n      class=\"clr-treenode-caret-icon\" shape=\"caret\"\n      [attr.dir]=\"expandService.expanded ? 'down' : 'right'\"></clr-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || _model.loading\">\n        <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input aria-hidden=\"true\" type=\"checkbox\" id=\"{{nodeId}}-check\" class=\"clr-checkbox\" \n           [checked]=\"_model.selected.value === STATES.SELECTED\"\n           [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n           (change)=\"_model.toggleSelection(featuresService.eager)\" \n           (focus)=\"focusTreeNode()\"\n           tabindex=\"-1\">\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\">\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable\">\n        <span *ngIf=\"ariaSelected\">\n          selected \n        </span>\n        <span *ngIf=\"!ariaSelected\">\n          unselected \n        </span>\n    </div>\n  </div>\n</div>\n<div class=\"clr-treenode-children\" \n    [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\" \n    [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\">\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n",
            providers: [
                UNIQUE_ID_PROVIDER,
                TREE_FEATURES_PROVIDER,
                IfExpandService,
                { provide: LoadingListener, useExisting: IfExpandService },
            ],
            animations: [
                trigger('toggleChildrenAnim', [
                    transition('collapsed => expanded', [style({ height: 0 }), animate(200, style({ height: '*' }))]),
                    transition('expanded => collapsed', [style({ height: '*' }), animate(200, style({ height: 0 }))]),
                    state('expanded', style({ height: '*', 'overflow-y': 'visible' })),
                    state('collapsed', style({ height: 0 })),
                ]),
            ],
            host: {
                '[attr.role]': '"treeitem"',
                '[class.clr-tree-node]': 'true',
            }
        }),
        __param(0, Inject(UNIQUE_ID)),
        __param(1, Inject(PLATFORM_ID)),
        __param(2, Optional()),
        __param(2, SkipSelf())
    ], ClrTreeNode);
    return ClrTreeNode;
}());
export { ClrTreeNode };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNsci9hbmd1bGFyLyIsInNvdXJjZXMiOlsiZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7O0FBRUgsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQ0wsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixRQUFRLEVBQ1IsS0FBSyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBQ04sUUFBUSxFQUNSLE1BQU0sRUFDTixXQUFXLEVBQ1gsU0FBUyxFQUNULFFBQVEsRUFDUixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXhDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUM5RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDOUUsT0FBTyxFQUFFLFlBQVksRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3ZGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQztBQUM5RixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDdkUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDaEYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFaEUsT0FBTyxFQUFFLG1CQUFtQixFQUFF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QUFBO1FBQ1YsV0FBQSxRQUFRLEVBQUUsQ0FBQTtPQVJGLFdBQVcsQ0FvT3ZCO0lBQUQsa0JBQUM7Q0FBQSxBQXBPRCxJQW9PQztTQXBPWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIwIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciwgc3RhdGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUExBVEZPUk1fSUQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2tpcFNlbGYsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgS2V5Q29kZXMgfSBmcm9tICcuLy4uLy4uL3V0aWxzL2VudW1zL2tleS1jb2Rlcy5lbnVtJztcbmltcG9ydCB7IElmRXhwYW5kU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWV4cGFuZGVkLnNlcnZpY2UnO1xuaW1wb3J0IHsga2V5VmFsaWRhdG9yLCBwcmV2ZW50QXJyb3dLZXlTY3JvbGwgfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9rZXktZm9jdXMvdXRpbCc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5pbXBvcnQgeyBVTklRVUVfSUQsIFVOSVFVRV9JRF9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuaW1wb3J0IHsgRGVjbGFyYXRpdmVUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvZGVjbGFyYXRpdmUtdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IENsclNlbGVjdGVkU3RhdGUgfSBmcm9tICcuL21vZGVscy9zZWxlY3RlZC1zdGF0ZS5lbnVtJztcbmltcG9ydCB7IFRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy90cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSwgVFJFRV9GRUFUVVJFU19QUk9WSURFUiB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IFRyZWVGb2N1c01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZvY3VzLW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUcmVlTm9kZUxpbmsgfSBmcm9tICcuL3RyZWUtbm9kZS1saW5rJztcblxuY29uc3QgTFZJRVdfQ09OVEVYVF9JTkRFWCA9IDg7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10cmVlLW5vZGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vdHJlZS1ub2RlLmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBVTklRVUVfSURfUFJPVklERVIsXG4gICAgVFJFRV9GRUFUVVJFU19QUk9WSURFUixcbiAgICBJZkV4cGFuZFNlcnZpY2UsXG4gICAgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBJZkV4cGFuZFNlcnZpY2UgfSxcbiAgXSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ3RvZ2dsZUNoaWxkcmVuQW5pbScsIFtcbiAgICAgIHRyYW5zaXRpb24oJ2NvbGxhcHNlZCA9PiBleHBhbmRlZCcsIFtzdHlsZSh7IGhlaWdodDogMCB9KSwgYW5pbWF0ZSgyMDAsIHN0eWxlKHsgaGVpZ2h0OiAnKicgfSkpXSksXG4gICAgICB0cmFuc2l0aW9uKCdleHBhbmRlZCA9PiBjb2xsYXBzZWQnLCBbc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSwgYW5pbWF0ZSgyMDAsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKV0pLFxuICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAndmlzaWJsZScgfSkpLFxuICAgICAgc3RhdGUoJ2NvbGxhcHNlZCcsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKSxcbiAgICBdKSxcbiAgXSxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5yb2xlXSc6ICdcInRyZWVpdGVtXCInLFxuICAgICdbY2xhc3MuY2xyLXRyZWUtbm9kZV0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRyZWVOb2RlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBTVEFURVMgPSBDbHJTZWxlY3RlZFN0YXRlO1xuICBwcml2YXRlIHNraXBFbWl0Q2hhbmdlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBub2RlSWQ6IHN0cmluZyxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcGFyZW50OiBDbHJUcmVlTm9kZTxUPixcbiAgICBwdWJsaWMgZmVhdHVyZXNTZXJ2aWNlOiBUcmVlRmVhdHVyZXNTZXJ2aWNlPFQ+LFxuICAgIHB1YmxpYyBleHBhbmRTZXJ2aWNlOiBJZkV4cGFuZFNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgZm9jdXNNYW5hZ2VyOiBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZTxUPixcbiAgICBpbmplY3RvcjogSW5qZWN0b3JcbiAgKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbikge1xuICAgICAgLy8gSSdtIGNvbXBsZXRlbHkgc3R1Y2ssIHdlIGhhdmUgdG8gaGFjayBpbnRvIHByaXZhdGUgcHJvcGVydGllcyB1bnRpbCBlaXRoZXJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE0OTM1IG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1OTk4XG4gICAgICAvLyBhcmUgZml4ZWRcbiAgICAgIC8vIFRoaXMgaXMgZm9yIG5vbi1pdnkgaW1wbGVtZW50YXRpb25zXG4gICAgICBpZiAoKDxhbnk+aW5qZWN0b3IpLnZpZXcpIHtcbiAgICAgICAgdGhpcy5fbW9kZWwgPSAoPGFueT5pbmplY3Rvcikudmlldy5jb250ZXh0LmNsck1vZGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXZ5IHB1dHMgdGhpcyBvbiBhIHNwZWNpZmljIGluZGV4IG9mIGEgX2xWaWV3IHByb3BlcnR5XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9tb2RlbCA9ICg8YW55PmluamVjdG9yKS5fbFZpZXdbTFZJRVdfQ09OVEVYVF9JTkRFWF0uY2xyTW9kZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvcmNlIGNhc3QgZm9yIG5vdywgbm90IHN1cmUgaG93IHRvIHRpZSB0aGUgY29ycmVjdCB0eXBlIGhlcmUgdG8gZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvblxuICAgICAgdGhpcy5fbW9kZWwgPSBuZXcgRGVjbGFyYXRpdmVUcmVlTm9kZU1vZGVsKHBhcmVudCA/IDxEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4+cGFyZW50Ll9tb2RlbCA6IG51bGwpO1xuICAgIH1cbiAgICB0aGlzLl9tb2RlbC5ub2RlSWQgPSB0aGlzLm5vZGVJZDtcbiAgfVxuXG4gIF9tb2RlbDogVHJlZU5vZGVNb2RlbDxUPjtcblxuICBpc0V4cGFuZGFibGUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmV4cGFuZGFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kYWJsZSB8fCAodGhpcy5fbW9kZWwuY2hpbGRyZW4gJiYgdGhpcy5fbW9kZWwuY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gIH1cblxuICBASW5wdXQoJ2NsclNlbGVjdGVkJylcbiAgZ2V0IHNlbGVjdGVkKCk6IENsclNlbGVjdGVkU3RhdGUgfCBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWU7XG4gIH1cbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBDbHJTZWxlY3RlZFN0YXRlIHwgYm9vbGVhbikge1xuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGZhbHN5IHN0YXRlcyBsaWtlIG51bGwgb3IgdW5kZWZpbmVkIGJlY2F1c2UgaXQncyBqdXN0IGVhc2llciB0aGFuIGFuc3dlcmluZyBxdWVzdGlvbnMuXG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHdpdGggc3RyaWN0IHR5cGluZyBvbiB0aGUgYXBwJ3Mgc2lkZSwgYnV0IGl0J3Mgbm90IHVwIHRvIHVzLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YWx1ZSA9IENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2ggYm9vbGVhbnMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgQ2xyU2VsZWN0ZWRTdGF0ZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA/IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBDbHJTZWxlY3RlZFN0YXRlLlVOU0VMRUNURUQ7XG4gICAgfVxuICAgIC8vIFdlIHByb3BhZ2F0ZSBvbmx5IGlmIHRoZSB0cmVlIGlzIGluIHNtYXJ0IG1vZGUsIGFuZCBza2lwIGVtaXR0aW5nIHRoZSBvdXRwdXQgd2hlbiB3ZSBzZXQgdGhlIGlucHV0XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMzA3M1xuICAgIHRoaXMuc2tpcEVtaXRDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX21vZGVsLnNldFNlbGVjdGVkKHZhbHVlLCB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciwgdGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIpO1xuICAgIHRoaXMuc2tpcEVtaXRDaGFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclNlbGVjdGVkQ2hhbmdlJykgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsclNlbGVjdGVkU3RhdGU+KGZhbHNlKTtcblxuICBnZXQgYXJpYVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzU2VydmljZS5zZWxlY3RhYmxlID8gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWUgPT09IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBudWxsO1xuICB9XG5cbiAgLy8gQWxsb3dzIHRoZSBjb25zdW1lciB0byBvdmVycmlkZSBvdXIgbG9naWMgZGVjaWRpbmcgaWYgYSBub2RlIGlzIGV4cGFuZGFibGUuXG4gIC8vIFVzZWZ1bCBmb3IgcmVjdXJzaXZlIHRyZWVzIHRoYXQgZG9uJ3Qgd2FudCB0byBwcmUtbG9hZCBvbmUgbGV2ZWwgYWhlYWQganVzdCB0byBrbm93IHdoaWNoIG5vZGVzIGFyZSBleHBhbmRhYmxlLlxuICBASW5wdXQoJ2NsckV4cGFuZGFibGUnKSBleHBhbmRhYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gIC8vIEknbSBjYXZpbmcgb24gdGhpcywgZm9yIHRyZWUgbm9kZXMgSSB0aGluayB3ZSBjYW4gdG9sZXJhdGUgaGF2aW5nIGEgdHdvLXdheSBiaW5kaW5nIG9uIHRoZSBjb21wb25lbnRcbiAgLy8gcmF0aGVyIHRoYW4gZW5mb3JjZSB0aGUgY2xySWZFeHBhbmRlZCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBmb3IgZHluYW1pYyBjYXNlcy4gTW9zdGx5IGJlY2F1c2UgZm9yIHRoZSBzbWFydFxuICAvLyBjYXNlLCB5b3UgY2FuJ3QgdXNlIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUsIGl0IHdvdWxkIG5lZWQgdG8gZ28gb24gYW4gbmctY29udGFpbmVyLlxuICBASW5wdXQoJ2NsckV4cGFuZGVkJylcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQ7XG4gIH1cbiAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGVkID0gdmFsdWU7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb250ZW50Q29udGFpbmVyVGFiaW5kZXggPSAtMTtcbiAgQFZpZXdDaGlsZCgnY29udGVudENvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiB0cnVlIH0pXG4gIHByaXZhdGUgY29udGVudENvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9tb2RlbC5leHBhbmRlZCA9IHRoaXMuZXhwYW5kZWQ7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9tb2RlbC5zZWxlY3RlZC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5za2lwRW1pdENoYW5nZSkpLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX21vZGVsLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c1JlcXVlc3Quc3Vic2NyaWJlKG5vZGVJZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVJZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyZWVOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKG5vZGVJZCA9PiB7XG4gICAgICAgIHRoaXMuY2hlY2tUYWJJbmRleChub2RlSWQpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fbW9kZWwuZGVzdHJveSgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvLyBAQ29udGVudENoaWxkIHdvdWxkIGhhdmUgYmVlbiBtb3JlIHN1Y2NpbmN0XG4gIC8vIGJ1dCBpdCBkb2Vzbid0IG9mZmVyIGEgd2F5IHRvIHF1ZXJ5IG9ubHkgYW4gaW1tZWRpYXRlIGNoaWxkXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyVHJlZU5vZGVMaW5rLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICBwcml2YXRlIHRyZWVOb2RlTGlua0xpc3Q6IFF1ZXJ5TGlzdDxDbHJUcmVlTm9kZUxpbms+O1xuXG4gIGdldCB0cmVlTm9kZUxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZU5vZGVMaW5rTGlzdCAmJiB0aGlzLnRyZWVOb2RlTGlua0xpc3QuZmlyc3Q7XG4gIH1cblxuICBwcml2YXRlIHNldFRhYkluZGV4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmNvbnRlbnRDb250YWluZXJUYWJpbmRleCA9IHZhbHVlO1xuICAgIHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrVGFiSW5kZXgobm9kZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLm5vZGVJZCAhPT0gbm9kZUlkICYmIHRoaXMuY29udGVudENvbnRhaW5lclRhYmluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5zZXRUYWJJbmRleCgtMSk7XG4gICAgfVxuICB9XG5cbiAgZm9jdXNUcmVlTm9kZSgpOiB2b2lkIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy5zZXRUYWJJbmRleCgwKTtcbiAgICAgIHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgYnJvYWRjYXN0Rm9jdXNPbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLmZvY3VzTWFuYWdlci5icm9hZGNhc3RGb2N1c2VkTm9kZSh0aGlzLm5vZGVJZCk7XG4gIH1cblxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBUd28gcmVhc29ucyB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3I6XG4gICAgLy8gMS4gdG8gcHJldmVudCBzY3JvbGxpbmcgb24gYXJyb3cga2V5c1xuICAgIC8vIDIuIEFzc2lzdGl2ZSBUZWNobm9sb2d5IGZvY3VzIGRpZmZlcnMgZnJvbSBLZXlib2FyZCBmb2N1cyBiZWhhdmlvci5cbiAgICAvLyAgICBCeSBkZWZhdWx0LCBwcmVzc2luZyBhcnJvdyBrZXkgbWFrZXMgQVQgZm9jdXMgZ28gaW50byB0aGUgbmVzdGVkIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAgcHJldmVudEFycm93S2V5U2Nyb2xsKGV2ZW50KTtcblxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMtMS4xLyNrZXlib2FyZC1pbnRlcmFjdGlvbi0yMlxuICAgIHN3aXRjaCAoa2V5VmFsaWRhdG9yKGV2ZW50LmtleSkpIHtcbiAgICAgIGNhc2UgS2V5Q29kZXMuQXJyb3dVcDpcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNOb2RlQWJvdmUodGhpcy5fbW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5Q29kZXMuQXJyb3dEb3duOlxuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c05vZGVCZWxvdyh0aGlzLl9tb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5BcnJvd1JpZ2h0OlxuICAgICAgICB0aGlzLmV4cGFuZE9yRm9jdXNGaXJzdENoaWxkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5BcnJvd0xlZnQ6XG4gICAgICAgIHRoaXMuY29sbGFwc2VPckZvY3VzUGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5Ib21lOlxuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLkVuZDpcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNMYXN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLkVudGVyOlxuICAgICAgICB0aGlzLnRyaWdnZXJEZWZhdWx0QWN0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5TcGFjZTpcbiAgICAgICAgLy8gdG8gcHJldmVudCBzY3JvbGxpbmcgb24gc3BhY2Uga2V5IGluIHRoaXMgc3BlY2lmaWMgY2FzZVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnRyaWdnZXJEZWZhdWx0QWN0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBleHBhbmRPckZvY3VzRmlyc3RDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYWxyZWFkeSBleHBhbmRlZCBhbmQgaGFzIGNoaWxkcmVuLCBmb2N1cyBpdHMgdmVyeSBmaXJzdCBjaGlsZFxuICAgICAgaWYgKHRoaXMuX21vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNOb2RlQmVsb3codGhpcy5fbW9kZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBtdXN0IGNoZWNrIGlmIHRoZSBub2RlIGlzIGV4cGFuZGFibGUsIGluIG9yZGVyIHRvIHNldCAuZXhwYW5kZWQgdG8gdHJ1ZSBmcm9tIGZhbHNlXG4gICAgICAvLyBiZWNhdXNlIHdlIHNob3VsZG4ndCBzZXQgLmV4cGFuZGVkIHRvIHRydWUgaWYgaXQncyBub3QgZXhwYW5kYWJsZSBub2RlXG4gICAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUoKSkge1xuICAgICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29sbGFwc2VPckZvY3VzUGFyZW50KCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNQYXJlbnQodGhpcy5fbW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlckRlZmF1bHRBY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudHJlZU5vZGVMaW5rKSB7XG4gICAgICB0aGlzLnRyZWVOb2RlTGluay5hY3RpdmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc1NlcnZpY2Uuc2VsZWN0YWJsZSkge1xuICAgICAgICB0aGlzLl9tb2RlbC50b2dnbGVTZWxlY3Rpb24odGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19